#!/usr/bin/python

import string, sys, getopt, os, ConfigParser
from difflib import get_close_matches
import Apse # for approximate searching

HOME = os.path.expanduser("~")
PATH = HOME + "/.sire/"
CONFIG = PATH + "/sirerc"
DB = PATH + "/siredb"

NAME = "sire"
VERSION = "0.1.4"
AUTHORS = "Oscar Eriksson"
EMAIL = "(oscar.eriks@gmail.com)"
LICENCE = '''License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.'''

C = { 
    'default' : "\033[0m",
    'bold'    : "\033[1m",
    'red'     : "\033[31m",
    'green'   : "\033[32m",
    'yellow'  : "\033[33m",
    'blue'    : "\033[34m",
    'magenta' : "\033[35m",
    'cyan'    : "\033[36m",
}

# Define arguemnts.
opts, args = getopt.getopt(
    sys.argv[1:], # Arguements from commandline.
    'lhva:d:c:f:',  # Short arguments.
    ['list', 'add=', 'change=', 'delete=', 'find=', 'help', 'version'] # Long arguments.
)





def usage():
    print '''Usage: [OPTION] [ARGUMENTS]
    --list, -l
    --add, -a           
    --delete, -d        
    --find, -f
    --change, -c        
    --help, -h          
    --version, -v       

For examples, see README.

Files:
    Configuration:
    ~/.sire/sirerc

    Database:
    ~/.sire/siredb
'''





# Prints version number, licence and authors with email.
def version():
    print NAME,VERSION,'\n',LICENCE,'\n\nWritten by: ',AUTHORS,EMAIL





# Internal function to check for already existing items.
def itemexists(db, item):
    for key in db.keys():
        for val in db[key].values():
            if val == item:
                return True

    return False





# Do an approximate string search using the Apse package.
def approxsearch(db, conf, sstr):
    reslist = []

    for str in sstr:
        # allow at most 3 edits 
        ap = Apse.Approx(str.lower(), edit=0)

        for key in db.keys():
            for val in db[key].values():
                val = val.lower()
        
                dist  = ap.dist(val)
                match = bool(ap.match(val))
                if match:
                    reslist.append(("%s" % (val), ("%d", dist)))

    if reslist != []:
        print "\nMatch found. Best match at the top.\n"

        reslist.sort(lambda x,y:cmp(x[1],y[1]))
        reslist.reverse()
        for res in reslist:
            print res[0]

    else:
        print "No matches found!"





def parseconfig(conffile):
    _config = {}
    cp = ConfigParser.ConfigParser()
    cp.read(conffile)
    for sec in cp.sections():
        name = string.lower(sec)
        for opt in cp.options(sec):
            _config[name + "." + string.lower(opt)] = string.strip(cp.get(sec, opt))
    return _config





# Print a catagory (status) description using bold and colors.
def printcatagory(catagory, config):
    if ("catagories." + catagory) not in config.keys():
        print "There is no Catagory description for catagory '" + catagory + "'!"
        sys.exit(1)

    if not ("colors." + catagory) in config.keys():
        if not "colors.defcol" in config.keys():
            color = ''

        else:
            color = C[config["colors.defcol"]]
    else:
        color = C[config["colors." + catagory]]

    print C["bold"], color, config["catagories." + catagory], "('" + catagory + "')", C["default"]





# Read the database.
# FIXME: I don't want to load a 500MB file each time I wan't to check what I can watch.
def parsedb(dbfile):
    db = {}
    id = 0
    f = file(dbfile, 'r')
    for line in f.readlines():
        parts = line.split(":", 2)
        parts[2] = parts[2][:-1]

        if not db.has_key(parts[0]):
            db[parts[0]] = {parts[1] : parts[2]}

        else:
            db[parts[0]][parts[1]] = parts[2]

        id += 1

    f.close()
    return db





# List duplicates, all or in a specific catagory.
def listdupes(db, conf, cat):
    found = False

    # If no catagory is specified, go through every catagory.
    if cat is None:
        first = True
        for d in db:
            i = 0
            dispt = True
            for j in range(0,len(db[d])):
                keys = db[d].keys()
                vals = db[d].values()
                key = keys.pop(i)
                val = vals.pop(i)
                if val in vals:
                    found = True
                    if dispt:
                        if not first:
                            print
                        first = False
                        printcatagory(d, conf)
                        dispt = False
                    print key, val
                i += 1

    elif not cat in db.keys():
        print "Catagory does not exist."
        sys.exit(1)

    # Use specified catagory.
    else:
        i = 0
        dispt = True
        for j in range(0,len(db[cat])):
            keys = db[cat].keys()
            vals = db[cat].values()
            key = keys.pop(i)
            val = vals.pop(i)
            if val in vals:
                found = True
                if dispt:
                    printcatagory(cat, conf)
                    dispt = False
                print key, val
            i += 1

    if not found:
        print "No duplicates found."





# List either all catagories or only the default catagory.
def list(db, config, catagory):
    # Nothing in database.
    if db == {}:
        print "Empty."
        sys.exit()

    # Only print the catagory titles.
    if catagory == "titles":
        for title in db.keys():
            printcatagory(title, config)

        sys.exit()

    # List duplicates.
    if catagory == "dupe":
        if len(sys.argv) < 4:
            listdupes(db, config, None)

        else:
            listdupes(db, config, sys.argv[3])

        sys.exit()

    if   catagory == "all" : dbs = db.keys()
    elif catagory == None  : dbs = config["defval.list"]
    else                   : dbs = [catagory]

    for catagory in dbs:
        if catagory not in db.keys():
            print "Empty catagory."
            sys.exit(1)

        dbsel = db[catagory].items()

        # Sorting is optional.
        if ("sort." + catagory) in config.keys():
            sortmethod = config["sort." + catagory]

        elif "defval.sort" in config.keys():
            sortmethod = config["defval.sort"]

        else:
            sortmethod = False

        if sortmethod is not False:
            # Sort by specified method.
            if sortmethod == "title":
                dbsel = sorted(db[catagory].items(), key=lambda (k,v): (v.lower(),k))
            elif sortmethod == "id":
                dbsel = sorted(db[catagory].items(), key=lambda (k,v): (int(k),v))
            else:
                dbsel = db[catagory].items()

        printcatagory(catagory, config)
        for id, title in dbsel:
            # Make titles aligned.
            spacer = ''
            for i in range(0, 3 - len(id)):
                spacer += ' '

            # Showing ID when listing is optional.
            if "general.showid" not in config.keys():
                print title
            
            elif config["general.showid"] == '1':
                print C['bold'] + id + spacer + C['default'], ':', title

            else:
                print title
 
        # For newline separator between items of different statuses.
        print





# Add an item to the database.
def add(db, config, name, catagory):
    if ("catagories." + catagory) not in config.keys():
        print "Specified catagory does not exist."
        sys.exit(1)

    l = []
    for k, v in db.iteritems():
        l += v.keys()

    id = "0"
    for i in l:
        if int(i) > int(id):
            id = str(i)

    id = str(int(id) + 1)

    f = open(DB, 'a')
    f.write(catagory + ":" + id + ":" + name + '\n')
    f.close()

    if itemexists(db, name):
        print C["bold"] + C["red"] + "Warning:" + C["default"], "Item already exists in catagory '" + catagory + "'."

    print "Saved '" + name + "' with id '" + id + "'."





# Delete an item from the database.
def delete(db, ids):
    for id in ids:
        deleted = False
        for d in db:
            if db[d].has_key(id):
                del db[d][id]
                deleted = True

        if deleted:
            print "Deleted item with ID '" + id + "'."
        else:
            print C["bold"] + C["red"] + "Warning: " + C["default"] + "Item with ID " + id + " not found."

    savedb(db)





# Save a changed database.
def savedb(db):
    f = open(DB, 'w')
    for d in db:
        for id in db[d]:
            f.write(d + ":" + id + ":" + db[d][id] + "\n")

    f.close()





# Change the status of an item with ID 'id'.
def change(db, conf, id, newcat):
    found = False
    for d in db:
        if id in db[d].keys():
            found = True
            break;

    if not found:
        print "no no"
        sys.exit(1)

    if not ("catagories." + newcat) in conf.keys():
        print "No such catagory ('" + newcat + "'). Add it in the sirerc first."
        sys.exit(1)

    title = db[d][id]
    db[newcat][id] = title
    del db[d][id]

    print "Changed catagory of title with ID '"+id+"' from '"+d+"' to '"+newcat+"'."

    savedb(db)





# Get the catagory of a title with a certain ID.
def getcat(db, id):
    for d in db:
        if id in db[d].keys():
            return d
    
    # We didn't find it.
    print "Catagory of title with ID '"+id+"' not found."
    sys.exit(1)





# Handle command line arguments.
def main():
    # Check if config and database files exists and are read- and writeable.
    if not os.path.exists(DB) or not os.path.exists(CONFIG):
        print "Database and/or config file not found. Should be in ~/.sire/!"
        sys.exit(1)

    # First read the database from the file.
    db = parsedb(DB)

    # Read the config file.
    config = parseconfig(CONFIG)

    # If no argument given, list items of default catagory.
    if len(sys.argv) == 1:
        list(db, config, None)
        sys.exit()

    # What to do with the different arguments.
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()

        elif o in ("-l", "--list"):
            if len(sys.argv) == 2:
                # Use default catagory first.
                catagory = config["defval.list"]
                list(db, config, catagory)
                sys.exit()

            catagory = sys.argv[2]
            list(db, config, catagory)

        elif o in ("-a", "--add"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

            # Use default catagory first.
            catagory = config["defval.add"]

            if len(sys.argv) == 4:
                catagory = sys.argv[3]

            title = sys.argv[2]
            add(db, config, title, catagory)

        elif o in ("-d", "--delete"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)
    
            id = sys.argv[2:]
            delete(db, id)

        elif o in ("-c", "--change"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)
    
            id = sys.argv[2]
            
            # User didn't specify what catagory to change to, try to use the default value.
            if len(sys.argv) < 4:
                curcat = getcat(db, id)

                # Try default for current catagory.
                newcat = "defval.change-" + curcat
                if not newcat in config.keys():
                    # Otherwise try to use default for all catagories.
                    if not "defval.change" in config.keys():
                        print "Need to specify catagory, default catagory not found."
                        sys.exit(1)

                    else:
                        newcat = config["defval.change"]
                else:
                    newcat = config[newcat]

            # User specified catagory.
            else:
                newcat = sys.argv[3]

            change(db, config, id, newcat)

        elif o in ("-f", "--find"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

            approxsearch(db, config, sys.argv[2:])


        elif o in ("-v", "--version"):
            version()
            sys.exit()

        else:
            usage()
            sys.exit(1)





# Call main().
if __name__ == "__main__":
    main()
    sys.exit()
