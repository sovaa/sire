#!/usr/bin/python

import string, sys, getopt, os, re, ConfigParser, time, shutil
import Apse # for approximate searching
import MySQLdb # database

HOME = os.path.expanduser("~")
PATH = HOME + "/.sire/"
CONFIG = PATH + "/sirerc"
DB = PATH + "/siredb"

NAME = "sire"
VERSION = "0.1.7"
AUTHORS = "Oscar Eriksson"
EMAIL = "(oscar.eriks@gmail.com)"
LICENCE = '''License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to move and redistribute it.
There is NO WARRANTY, to the extent permitted by law.'''

C = { 
    'default' : "\033[0m",
    'd'       : "\033[0m",
    'bold'    : "\033[1m",
    'b'       : "\033[1m",
    'red'     : "\033[31m",
    'green'   : "\033[32m",
    'g'   : "\033[32m",
    'yellow'  : "\033[33m",
    'blue'    : "\033[34m",
    'magenta' : "\033[35m",
    'm'       : "\033[35m",
    'cyan'    : "\033[36m",
}

# Define arguemnts.
opts, args = getopt.getopt(
    sys.argv[1:], # Arguements from commandline.
    'we:nl:hotcvfiadm',  # Short arguments.
    ['no-newline', 'no-catagory', 'no-color', 'edits=', 'no-id', 'list=', 'change', 'info', 'add', 'move', 'delete', 'find', 'help', 'version'] # Long arguments.
)





def usage():
    print '''Usage: [OPTION] [ARGUMENTS]
    --list, -l [category]                        List either default category or a specified one.
    --add, -a <value> [category]                 Add an item to a category.
    --delete, -d <ID1[ ID2[ ...]]>               Delete one or more items.
    --info, -i <ID1[ ID2[ ...]]>                 Show formated table with information about titles.
    --find, -f <value1[ value2[ ...]]>           Find titles matching values.
    --move, -m <ID> <catgory>                    Mode an item to another category.
    --change, -c <ID1[,ID2[,...]]> <new value>   Change the title of one or more items.
    --noid, -n                                   Don't show ID when listing, even if specified to do so in sirerc.
    --edits, -e                                  Used -before- (--find, -f) to specify the number of edits allowed to search value.
    --noid, -n                                   Don't show ID when listing (used -before- (--list, -l)).
    --help, -h                                   Show this help.
    --version, -v                                Show the current version.

For examples, see README.

Files:
    Configuration:
    ~/.sire/sirerc

    Database:
    ~/.sire/siredb
'''





# Prints version number, licence and authors with email.
def version():
    print NAME,VERSION,'\n',LICENCE,'\n\nWritten by: ',AUTHORS,EMAIL





# Internal function to check for already existing items.
def itemexists(db, config, item):
    if flatfile(config):
        for key in db.keys():
            for val in db[key].values():
                if val[1] == item:
                    return True

	return False

    # else we're using sql
    cursor = dbexec(db, "select * from item where title = '"+item+"'", None)
    if len(cursor.fetchall()) > 1:
        return True

    return False




def replace_all(text, dic):
    for i, j in dic.iteritems():
        text = text.replace(i, j)
    
    return text





# Do an approximate string search using the Apse package.
def approxsearch(db, conf, edits, sstr):
    reslist = []
    reps = {'.':' ', '_':' ', '-':' '}

    if edits is 0:
        if "find.edits" in conf.keys():
	    edits = int(conf["find.edits"])
        else:
	    edits = 0
    
    if edits > 10:
        edits = 10

    elif edits < 0:
        edits = 0

    for str in sstr:
        # allow at most 'edits' edits 
        ap = Apse.Approx(str.lower(), edit=edits)

        for key in db.keys():
            for (id, val) in db[key].items():
		val = val[1]
                val_orig = val.lower()
                fnd = bool(ap.match(val_orig))
		dst = ap.dist(val_orig)
		res = (id, "%s" % val, ("%d", dst), key)

                if fnd and val not in reslist:
		    reslist.append(res)

		# Try to match if we replace some characters.
		val_rep = replace_all(val.lower(), reps)
                fnd_rep = bool(ap.match(val_rep))
		dst_rep = ap.dist(val)
		res_rep = (id, "%s" % val, ("%d", dst_rep), key)

	        if not fnd and fnd_rep and val not in reslist:
		    reslist.append(res_rep)

    if reslist != []:
	showcats = False
	if "find.showcats" in conf.keys() and conf["find.showcats"] == '1':
	    showcats = True

        print "Match found. Best match at the top.\n"
	old_cat = None

	if showcats:
            reslist.sort(lambda x,y:cmp(x[3],y[3]))
	    reslist.reverse()
	
	else:
            reslist.sort(lambda x,y:cmp(x[2],y[2]))
	    reslist.reverse()

        for res in reslist:
	    if showcats:
		if old_cat is None or res[3] != old_cat:
		    print
		    printcategory(res[3], conf, nocolor)
		    old_cat = res[3]

            # Make titles aligned.
            spacer = ''
            for i in range(0, 3 - len(res[0])):
                spacer += ' '

            # Showing ID when listing is optional.
            if "general.showid" not in conf.keys():
                print res[1]
            
            elif conf["general.showid"] == '1':
                print C['bold'] + res[0] + C['default'], spacer + ':', res[1]

    else:
        print "No matches found!"





def parseconfig(conffile):
    _config = {}
    cp = ConfigParser.ConfigParser()
    cp.read(conffile)
    for sec in cp.sections():
        name = string.lower(sec)
        for opt in cp.options(sec):
            _config[name + "." + string.lower(opt)] = string.strip(cp.get(sec, opt))
    return _config





# Print a category (status) description using bold and colors.
def printcategory(category, config, nocolor):
    if ("categories." + category) not in config.keys():
        error("There is no Catagory description for category '"+c(category)+"'!")
        sys.exit(1)

    if not ("colors." + category) in config.keys():
        if not "colors.defcol" in config.keys():
            color = ''

        else:
            color = C[config["colors.defcol"]]
    else:
        color = C[config["colors." + category]]

    if nocolor:
	print "  " + config["categories." + category], "('" + category + "')"
    
    else:
	print C["bold"], color, config["categories." + category], "('" + category + "')", C["default"]





# Read the database.
# FIXME: I don't want to load a 500MB file each time I wan't to check what I can watch.
def parsedb(dbfile):
    db = {}
    f = file(dbfile, 'r')
    for line in f.readlines():
        parts = line.split(":", 3)
        parts[3] = parts[3][:-1]

        if not db.has_key(parts[0]):
            db[parts[0]] = {parts[1] : (parts[2], parts[3])}

        else:
            db[parts[0]][parts[1]] = (parts[2], parts[3])


    f.close()
    return db





# List duplicates, all or in a specific category.
# FIXME: O(n^4) complexity ffs
def listdupes(db, conf, cat):
    dupeids = []

    if flatfile(conf):
	alldbs = db.keys()
    else:
	alldbs = getcatsql(db)

    # If no category is specified, go through every category.
    if cat is None:
        for d in alldbs:
	    if flatfile(conf):
		dkeys = db[d].keys()
		dvals = db[d].values()
	    else:
	        cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+d+"'", None)
		result = cursor.fetchall()
                dkeys = [x[0] for x in result]
		dvals = [x[1] for x in result]

            while dvals != []:
                dval = dvals.pop()
                dkey = dkeys.pop()
		if flatfile(conf):
		    dval = dval[1]

                for dd in alldbs:
		    if flatfile(conf):
			ddkeys = db[dd].keys()
			ddvals = db[dd].values()
		    else:
		        cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+dd+"'", None)
			result = cursor.fetchall()
		        ddkeys = [x[0] for x in result]
			ddvals = [x[1] for x in result]
    
                    while ddvals != []:
                        ddval = ddvals.pop()
                        ddkey = ddkeys.pop()
			if flatfile(conf):
			    ddval = ddval[1]

			if dkey is ddkey:
			    continue
    
                        if dval == ddval:
                            if dkey not in dupeids:
                                dupeids.append(dkey)
                                print dkey, dval, "(%s)" % d

                            if ddkey not in dupeids:
                                dupeids.append(ddkey)
                                print ddkey, ddval, "(%s)" % dd

    elif not cat in alldbs:
        print "Catagory does not exist."
        sys.exit(1)

    # Use specified category.
    else:
        if flatfile(conf):
            dkeys = db[cat].keys()
	    dvals = db[cat].values()
	else:
	    cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+cat+"'", None)
            dkeys = [x[0] for x in cursor.fetchall()]
	    dvals = [x[1] for x in cursor.fetchall()]

        while dvals != []:
            dval = dvals.pop()
            dkey = dkeys.pop()
	    dval = dval[1]

            for (k, v) in zip(dkeys, dvals):
                if dval == v[1]:
                    dupeids.append(dval)
                    print dkey, dval, "(%s)" % cat
                    print k, v[1], "(%s)" % cat
                    print

    if dupeids == []:
        print "No duplicates found."





# List either all categories or only the default category.
def list(db, config, category, noid, nocolor, nocat, nonewline):
    if flatfile(config):
        # Nothing in database.
        if db == {}:
            error("Your database is empty.")
            sys.exit()

	alldbs = db.keys()

    else:
	alldbs = getcatsql(db)

    # FIXME sql
    # Only print the category titles.
    if category == "titles":
        for title in alldbs:
            printcategory(title, config, nocolor)

        sys.exit()

    if nonewline:
	newline = ", "
    else:
	newline = "\n"

    # FIXME sql
    # List duplicates.
    if category == "dupe":
        if len(sys.argv) < 4:
            listdupes(db, config, None)

        else:
            listdupes(db, config, sys.argv[3])

        sys.exit()

    if category == "all":  dbs = alldbs
    elif category == None: dbs = config["defval.list"]
    else:                  dbs = [category]

    for category in dbs:
        if category not in alldbs:
            error("Empty category '"+c(category)+"'.")
            sys.exit(1)

        if flatfile(config):
	    dbsel = db[category].items()

	else:
	    cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+category+"'", None)
	    dbsel = cursor.fetchall()

        # Sorting is optional.
        if ("sort." + category) in config.keys():
            sortmethod = config["sort." + category]

        elif "defval.sort" in config.keys():
            sortmethod = config["defval.sort"]

        else:
            sortmethod = False

        if sortmethod is not False:
            # Sort by specified method.
	    if flatfile(config):
                if sortmethod == "title":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[1].lower(),k))
                elif sortmethod == "id":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (int(k),v[1]))
                elif sortmethod == "time":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[0], k))
                else:
                    dbsel = dbsel

	    else:
                if sortmethod == "title":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b): (v.lower(),k,a,b))
                elif sortmethod == "id":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b): (int(k),v,a,b))
                elif sortmethod == "time":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b): (a,k,v,b))
                else:
                    dbsel = dbsel

	if not nocat: 
            printcategory(category, config, nocolor)

	if flatfile(config):
            for id, title in dbsel:
                # Make titles aligned.
	        title = title[1]
                spacer = ''
                for i in range(0, 3 - len(id)):
		    spacer += ' '

                # Showing ID when listing is optional.
                if "general.showid" not in config.keys():
                    print title

		elif noid:
		    print title
            
                elif config["general.showid"] == '1':
		    if not nocolor:
	                print C['bold'] + id + C['default'], spacer + ':', title

		    else:
	                print id, spacer + ':', title

	        else:
		    print title
 
            # For newline separator between items of different statuses.
            print

	# SQL
	else:
	    output = ''
            for id, title, date, cat in dbsel:
                # Make titles aligned.
		id = str(id)
                spacer = ''
                for i in range(0, 3 - len(id)):
		    spacer += ' '

                # Showing ID when listing is optional.
                if "general.showid" not in config.keys() or noid:
                    output += title + newline
            
                elif config["general.showid"] == '1':
		    if not nocolor:
			output += C['bold'] + id + C['default'] + ' ' + spacer + ': ' + title + newline
		    else:
			output += id + ' ' + spacer + ': ' + title + newline

	        else:
		    output += title + newline
 
    output = output.strip()
    if output[-1] == ',':
    	output = output[:-1]

    print output
    return


# Add an item to the database.
def add(db, config, name, category):
    if ("categories." + category) not in config.keys():
        error("Specified category does not exist.")
        sys.exit(1)

    if itemexists(db, config, name):
        print C["bold"] + C["red"] + "Warning:" + C["default"], "Item already exists in category '" + category + "'."
	sys.exit(1)

    # time.time() returns float, so throw away the ms, then convert to string for writing
    date = str(int(time.time()))

    if flatfile(config):
        l = []
	for k, v in db.iteritems():
	    l += v.keys()

        id = "0"
        for i in l:
            if int(i) > int(id):
                id = str(i)

        id = str(int(id) + 1)

	f = open(DB, 'a')
	f.write(category + ":" + id + ":" + date + ":" + name + '\n')
	f.close()

    else:
	cursor = dbexec(db, "SELECT * FROM curid", None)
	id = cursor.fetchall()[0][0] + 1;
	dbexec(db, "UPDATE curid SET id = id + 1", None)
	dbexec(db, "INSERT INTO item (id, title, date, cat) VALUES (%s, %s, %s, %s)", (id, name, date, category))


    if itemexists(db, config, name):
        print C["bold"] + C["red"] + "Warning:" + C["default"], "Item already exists in category '" + category + "'."

    print "Saved '" + c(name) + "' with id '" + c(str(id)) + "'."





# Execute SQL statement.
def dbexec(db, template, values):
    cursor = db.cursor()
    if values is None:
        cursor.execute(template)
    else:
        cursor.execute(template, values)
    return cursor





# Delete an item from the database.
def delete(db, conf, ids):
    if flatfile(conf):
	alldbs = db.keys()
    else:
	alldbs = getcatsql(db)

    for id in ids:
        deleted = False
        for d in alldbs:
	    if flatfile(conf):
                if db[d].has_key(id):
		    title = db[d][id][1]
		    date = db[d][id][0]
                    del db[d][id]
                    deleted = True
		    break

	    # SQL
	    else:
		cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
		result = cursor.fetchall()
		if len(result) == 0:
		    continue

	        title = result[0][1]
                date = result[0][2]
                dbexec(db, "DELETE FROM item WHERE id = '"+id+"'", None)
                deleted = True
	        break

        if deleted:
	    date = timepassed(date)

            print "Deleted item with ID '"+c(id)+"' and title '"+c(title)+"' from category '"+c(d)+"'."
	    print "It was in that category for "+date[0], "years,", date[1], \
		"days,", date[2], "hours,", date[3], "minutes and", date[4], "seconds."

        else:
            error("Item with ID '"+c(id)+"' not found.")

    savedb(db, conf)


def getcatsql(db):
    cursor = dbexec(db, "SELECT DISTINCT cat FROM item", None)
    return [x[0] for x in cursor.fetchall()]

def timepassed(date):
    date = int(time.time()- int(date))
    return (str(date/60/60/24/365), str(date/60/60/24 % 365), \
	str(date/60/60 % 24), str(date/60 % 60), str(date % 60))

def error(text):
    print C["bold"] + C["red"] + "Error: " + C["default"] + text


# Save a changed database.
def savedb(db, conf):
    if not flatfile(conf):
	return
    
    f = open(DB, 'w')
    for d in db:
        for id in db[d]:
            f.write(d + ":" + id + ":" + db[d][id][0] + ":" + db[d][id][1] + "\n")

    f.close()





# Change the value of an item with ID 'id'.
def change(db, conf, id, val_orig):
    # Find all '%([0-9+)' in 'val'.
    id = id.split(',')
    res = re.findall(r'\%\(([0-9]+|#)\)', val_orig)

    if res != []:
	for i in id:
	    val = val_orig
	    for v in res:
		# This means "if %(#), do this".
		if not cmp(v, '#'):
		    if flatfile(conf):
			rval = db[getcat(db, i)][i][1]
		    else:
			cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None)
			result = cursor.fetchall()
			rval = result[0][1]

		else:
		    if flatfile(conf):
			rval = db[getcat(db, v)][v][1]
		    else:
			cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+v+"'", None)
			result = cursor.fetchall()
			rval = result[0][1]

		p = re.compile('\%\(' + v + '\)')
		val = p.sub(rval, val)

	    if flatfile(conf):
		cat = getcat(db, i)
		old = db[cat][i][1]
		date = db[cat][i][0]
		db[cat][i] = (date, val)
	    else:
		cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None)
		result = cursor.fetchall()
		old = result[0][1]
		dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None)

	    print "Changed item '"+c(i)+"' from '"+c(old)+"' to '" + c(val)+"'."

    else:
	for i in id:
	    val = val_orig
	    if flatfile(conf):
		cat = getcat(db, i)
		old = db[cat][i][1]
		date = db[cat][i][0]
		db[cat][i] = (date, val)
	    else:
		cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None)
		result = cursor.fetchall()
		old = result[0][1]
		dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None)

	    print "Changed item '"+c(i)+"' from '"+c(old)+"' to '" + c(val)+"'."

    savedb(db, conf)




# Move an item with ID 'id' to a new category.
def move(db, conf, id, newcat):
    if not ("categories." + newcat) in conf.keys():
        error("No such category '" + c(newcat) + "'. Add it in the sirerc first.")
        sys.exit(1)

    newdate = str(int(time.time()))

    if flatfile(conf):
        found = False
        for d in db:
            if id in db[d].keys():
                found = True
	        break;

        if not found:
            error("No item with ID '"+c(id)+"'.")
            sys.exit(1)

        date = timepassed(db[d][id][0])
        newdate = str(int(time.time()))
        title = db[d][id][1]

        if db.has_key(newcat):
            db[newcat][id] = (newdate, title)
        else:
	    db[newcat] = dict([(id, (newdate, title))])

        del db[d][id]

    # SQL
    else:
        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
	result = cursor.fetchall()
	if len(result) == 0:
            error("No item with ID '"+c(id)+"'.")
            sys.exit(1)

	dbexec(db, "UPDATE item SET cat = '"+newcat+"' WHERE id = '"+id+"'", None)
	dbexec(db, "UPDATE item SET date = '"+newdate+"' WHERE id = '"+id+"'", None)
	date = timepassed(result[0][2])
	title = result[0][1]
	d = result[0][3]

    print "Moved item with ID '"+c(id)+"' and title '"+c(title)+"' from category '"+c(d)+"' to '"+c(newcat)+"'."
    print "It was in that category for "+date[0], "years,", date[1], \
	"days,", date[2], "hours,", date[3], "minutes and", date[4], "seconds."

    savedb(db, conf)


def c(text):
    return C['g'] + text + C['d']


# Get the category of a title with a certain ID.
def getcat(db, id):
    for d in db:
        if id in db[d].keys():
            return d
    
    # We didn't find it.
    error("Catagory of title with ID '"+c(id)+"' not found.")
    sys.exit(1)





# Detirmine if we're using flatfile or mysql as database.
def flatfile(config):
    if ("database.type" not in config.keys()):
	return True

    if config["database.type"] == "mysql":
	return False

    return True





# Prints formated table with info about items with specified IDs.
def info(db, conf, ids):
    sl_id = 1
    sl_title = 1
    sl_date = 1
    sl_date_added = 1
    sl_category = 1
    items = []

    if flatfile(conf):
	alldbs = db
    else:
	alldbs = getcatsql(db)

    for id in ids:
	found = False
        for d in alldbs:
	    if flatfile(conf):
		catids = db[d].keys()
	    else:
		cursor = dbexec(db, "SELECT DISTINCT id FROM item WHERE cat = '"+d+"'", None)
		catids = [int(x[0]) for x in cursor.fetchall()]

	    if int(id) in catids:
		found = True

		if flatfile(conf):
		    title = db[d][id][1]
		    date = db[d][id][0]
		else:
		    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
		    result = cursor.fetchall()
		    title = result[0][1]
		    date = result[0][2]

		da = time.gmtime(int(date))
		date_added = str(da[0]) + "-" + str(da[1]) + "-" + str(da[2]) + ", " + \
		    str(da[3]) + ":" + str(da[4]) + ":" + str(da[5])
		date_in_cat = timepassed(date)
		cat = conf["categories." + d]

		items.append((id, title, cat, date_added, date_in_cat))

		if len(id) > sl_id:
		    sl_id = len(id)

		if len(title) > sl_title:
		    sl_title = len(title)

		if len(date_added) > sl_date_added:
		    sl_date_added = len(date_added)

		if len(cat) > sl_category:
		    sl_category = len(cat)

		break;
	
	if not found:
	    error("There is no item with ID '" + c(id) + "'.")

    print

    sys.stdout.write("ID")
    for i in (range(sl_id+1)):
	sys.stdout.write(" ")
    sys.stdout.write("TITLE")
    for i in (range(sl_title - 2)):
	sys.stdout.write(" ")
    sys.stdout.write("CATEGORY")
    for i in (range(sl_category - 5)):
	sys.stdout.write(" ")
    sys.stdout.write("DATE ADDED")
    for i in (range(sl_date_added - 7)):
	sys.stdout.write(" ")
    sys.stdout.write("TIME IN CATAGORY")

    print
    print
    for item in items:
        sys.stdout.write(item[0])
        for i in (range(sl_id         - len(item[0]) + 3)):
    	    sys.stdout.write(" ")

        sys.stdout.write(item[1])
        for i in (range(sl_title      - len(item[1]) + 3)):
    	    sys.stdout.write(" ")

        sys.stdout.write(item[2])
        for i in (range(sl_category   - len(item[2]) + 3)):
	    sys.stdout.write(" ")

        sys.stdout.write(item[3])
	for i in (range(sl_date_added - len(item[3]) + 3)):
	    sys.stdout.write(" ")

        print item[4][0]+"y", item[4][1]+"d", item[4][2]+"h", item[4][3]+"m", item[4][4]+"s"
	




# Handle command line arguments.
def main():
    # Check if config and database files exists and are read- and writeable.
    if not os.path.exists(DB) or not os.path.exists(CONFIG):
        print C['r'] + "Error: " + C['d'] + "Database and/or config file not found. Should be in ~/.sire/!"
        sys.exit(1)

    # Read the config file.
    config = parseconfig(CONFIG)

    if flatfile(config):
	# Always backup the database before ding anything. Will overwrite older backup.
        shutil.copy(DB, PATH + "/.siredb.backup")

        # First read the database from the file.
        db = parsedb(DB)

    else:
	dbhost = config["database.host"]
	dbuser = config["database.user"]
	dbpass = config["database.pass"]
	dbname = config["database.name"]

        db = MySQLdb.connect(dbhost, dbuser, dbpass, dbname)

    # For (--find, -f).
    edits = 0
    edit_allowed = False

    dolist = False

    # For (--noid, -n).
    noid = False
    nocat = False
    nocolor = False
    catagory = None
    nonewline = False
    dolist = True



    # What to do with the different arguments.
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()

	elif o in ("-n", "--no-id"):
	    noid = True
	    continue

	elif o in ("-t", "--no-catagory"):
	    nocat = True
	    continue

	elif o in ("-o", "--no-color"):
	    nocolor = True
	    continue

        elif o in ("-l", "--list"):
            catagory = a
	    dolist = True
	    continue

	elif o in ("-w", "--no-newline"):
	    nonewline = True
	    continue

        elif o in ("-a", "--add"):
	    dolist = False
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

            # Use default category first.
            category = config["defval.add"]

            if len(sys.argv) == 4:
                category = sys.argv[3]

            title = sys.argv[2]
            add(db, config, title, category)
	    continue

	elif o in ("-i", "--info"):
	    dolist = False
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

	    id = sys.argv[2:]
	    info(db, config, id)
	    continue

        elif o in ("-d", "--delete"):
	    dolist = False
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)
    
            id = sys.argv[2:]
            delete(db, config, id)
	    continue

	elif o in ("-c", "--change"):
	    dolist = False
	    if len(sys.argv) < 4:
		usage()
		sys.exit(1)

	    id = sys.argv[2]
	    val = sys.argv[3]

	    change(db, config, id, val)
	    continue

        elif o in ("-m", "--move"):
	    dolist = False
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)
    
            id = sys.argv[2]
            
            # User didn't specify what category to move to, try to use the default value.
            if len(sys.argv) < 4:
		if flatfile(config):
                    curcat = getcat(db, id)
		else:
		    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
		    result = cursor.fetchall()
		    curcat = result[0][3]

                # Try default for current category.
                newcat = "defval.move-" + curcat
                if not newcat in config.keys():
                    # Otherwise try to use default for all categories.
                    if not "defval.move" in config.keys():
                        error("Need to specify category, default category not found.")
                        sys.exit(1)

                    else:
                        newcat = config["defval.move"]
                else:
                    newcat = config[newcat]

            # User specified category.
            else:
                newcat = sys.argv[3]

            move(db, config, id, newcat)
	    continue

	elif o in ("-e", "--edits"):
	    dolist = False
            if len(sys.argv) < 5:
                usage()
                sys.exit(1)

	    edits = int(a)
	    edit_allowed = True
	    continue
	    
        elif o in ("-f", "--find"):
	    dolist = False
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

	    if edit_allowed:
                approxsearch(db, config, edits, sys.argv[4:])

	    else:
                approxsearch(db, config, 0, sys.argv[2:])

	    continue

        elif o in ("-v", "--version"):
            version()
            sys.exit()

        else:
            usage()
            sys.exit(1)

    # If no argument given, list items of default category.
    if dolist:
        list(db, config, catagory, noid, nocolor, nocat, nonewline)
    sys.exit()

    return




# Call main().
if __name__ == "__main__":
    main()
    sys.exit()
