#!/usr/bin/python

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


import string, sys, getopt, os, ConfigParser, time, shutil
import MySQLdb # database
from optparse import OptionParser
from optparse import OptionGroup

HOME = os.path.expanduser("~")
PATH = HOME + "/.sire/"
CONFIG = PATH + "/sirerc"
DB = PATH + "/siredb"
ALTDB = PATH + "/altdb/"
ALTRC = PATH + "/altrc/"
DBBAK = PATH + "dbbak"

NAME = "sire"
VERSION = "0.2.3"
AUTHORS = "Oscar Eriksson"
EMAIL = "(oscar.eriks@gmail.com)"
LICENCE = '''License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to move and redistribute it.
There is NO WARRANTY, to the extent permitted by law.'''

C = { 
    'default' : "\033[0m",
    'd'       : "\033[0m",
    'bold'    : "\033[1m",
    'b'       : "\033[1m",
    'red'     : "\033[31m",
    'green'   : "\033[32m",
    'g'       : "\033[32m",
    'yellow'  : "\033[33m",
    'blue'    : "\033[34m",
    'magenta' : "\033[35m",
    'm'       : "\033[35m",
    'cyan'    : "\033[36m",
}

ERROR = {
    'item':        "Item with ID '%s' does not exist.",
    'dest':        "Need destination. Use --destination, -d.",
    'destcat':     "Need to specify a category ID. Specify it with --destination, -D.",
    'destchg':     "No change-to value specified. Specify it using --destination, -D.",
    'destscore':   "Need an item to assign the score to. Use --destination, -D.",
    'destdefcat':  "Need to specify category, default category not found. Use --destination, -D or edit your config file.", 
    'conf':        "Config file didn't exist. I created it for you. Populate it before continuing.",
    'catdesc':     "There is no category description for category '%s'.",
    'nocat':       "Category '%s' does not exist.",
    'notitle':     "There is no item with title '%s'.",
    'nodb':        "Database didn't exist. I created it for you.",
    'emptydb':     "Your database is empty.",
    'emptycat':    "Empty category '%s'.",
    'dbcat':       "Database and/or config file not found. Should be in '~/.sire/'.",
    'defadd':      "defval.add not specified in config file, and no category specified on command line when adding.",
    'deflist':     "defval.list is not specified in config file, and no category specified on command line when listing.",
    'bad_id':      "'%s' is not a valid ID.",
    'bad_cat':     "Bad chars in destination ('%s'). ' and \ are not allowed.",
    'bad_range':   "'%s' is not a valid range.",
    'dupe_cat':    "Category with ID '%s' already exists with the title '%s'.",
}    

class miscfunctions:
    def __init__(self):
        self.info = {
            'force': False, 
            'verbose': 1, 
            'color': True, 
            'id': True, 
            'newline': True,
            'category': True, 
            'edits': 0, 
            'pretend': False, 
            'daysago': 0, 
            'sort': None,
            'score': True
        }
        return

    def set(self, what, value):
        self.info[what] = value
        return

    def get(self, what):
        return self.info[what]

misc = miscfunctions()



def parseargs():
    parser = OptionParser()
    htxt = {
        "--list":         "List the specified category.",
        "--add":          "Add an item to a category. If no destination (category in this case) is specified (using --destination, -D) the default add " + \
                          "category will be used (specified in config file).",
        "--destination":  "Specify to which category an item is to be added/moved/etc., or a new value to be used when using --change, -c.",
        "--delete":       "Delete specified comma separated IDs.",
        "--info":         "Show formated table with information about items with the specified comma separated IDs.",
        "--find":         "Find titles matching specified value.",
        "--move":         "Move title with specified ID to another category. If no destination (category in this case) is specified (using --destination, " + \
                          "-D) the default move category will be used (specified in config file).",
        "--change":       "Change the title of one or more items with the specified comma separated IDs to a new value, specified using --destination, " + \
                          "-D. Here the destination can contain %(#) for self referencing, or %(123) for referencing title with ID 123. See the examples " + \
                          "for more information.",
        "--no-id":        "Hide ID when listing, even if specified in config file to show them.",
        "--no-category":  "Hide category title when listing a category.",
        "--no-color":     "Don't use any color/bold when printing.",
        "--no-newline":   "Don't print newlines. Use ', ' instead of '\\n' (newline) when listing one or more categories.",
        "--no-score":     "Don't print score when listing. Overrides setting in configuration.",
        "--show-score":   "Show score when printing. Overrides setting in configuration.",
        "--add-category": "Add a new category (will edit your config file). Use --destination, -D to specify the category ID.",
        "--force":        "Ignore warnings and continue execution anyway.",
        "--version":      "Show the current version.",
        "--profile":      "Use an alternative profile. A profile name is the name of the config file and the database file. When an alternative profile " + \
                          "is used, their config an db files will be located in ~/.sire/altdb/<name> and ~/.sire/altrc/<name>.",
        "--edits":        "Specify the number of allowed edits to the search value when using --find, -f.",
        "--quiet":        "Be quiet. Don't print notices or warnings. Errors will still be printed.",
        "--verbose":      "Be verbose. Print notices, warnings and errors.",
        "--hide-all":     "Same as -LINC (--no-color --no-id --no-newline --no-category).",
        "--pretend":      "Only pretend to do the speicified things.",
        "--days-ago":     "Only list items added no longer ago than this.",
        "--sort":         "Specify what to sort by. Overrides setting in configuration.",
        "--score":        "Assign a score to an item.",
        "--restore-db":   "Restore the DB from the backup."
    }
    
    group = OptionGroup(parser, "Hide and/or change output options", "These options will hide or change different types of output.")
    group.add_option("-I", "--no-id", action = "store_true", default = False, dest = "noid", help = htxt["--no-id"])
    group.add_option("-C", "--no-category", action = "store_false", default = True, dest = "printcat", help = htxt["--no-category"])
    group.add_option("-L", "--no-color", action = "store_false", default = True, dest = "printcolor", help = htxt["--no-color"])
    group.add_option("-N", "--no-newline", action = "store_false", default = True, dest = "printnewline", help = htxt["--no-newline"])
    group.add_option("-S", "--no-score", action = "store_true", dest = "noscore", default = None, help = htxt["--no-score"])
    group.add_option("-W", "--show-score", action = "store_false", dest = "noscore", default = None, help = htxt["--show-score"])
    group.add_option("-H", "--hide-all", action = "store_true", default = False, dest = "hide", help = htxt["--hide-all"])
    group.add_option("-q", "--quiet", action = "store_const", const = 0, dest = "verbose", default = 1, help = htxt["--quiet"])
    group.add_option("-v", "--verbose", action = "store_const", const = 2, dest = "verbose", default = 1, help = htxt["--verbose"])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Modify options", "These options will modify items in categories in some way.")
    group.add_option("-a", "--add", dest = "add", help = htxt["--add"], metavar = "TITLE")
    group.add_option("-d", "--delete", dest = "delete", help = htxt["--delete"], metavar = "ID1[,ID2[...]]")
    group.add_option("-m", "--move", type="int", dest = "move", help = htxt["--move"], metavar = "ID")
    group.add_option("-c", "--change", dest = "change", help = htxt["--change"], metavar = "ID1[,ID2[...]]")
    group.add_option("-A", "--add-category", dest = "addcat", help = htxt["--add-category"], metavar = "TITLE")
    group.add_option("-b", "--restore-db", action = "store_true", dest = "restore", help = htxt["--restore-db"])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Printing options", "These options only prints information and does not modify anything.")
    group.add_option("-f", "--find", dest = "find", help = htxt["--find"], metavar = "VALUE")
    group.add_option("-e", "--edits", type="int", dest = "edits", help = htxt["--edits"], metavar = "VALUE")
    group.add_option("-i", "--info", dest = "info", help = htxt["--info"], metavar = "ID1[,ID2[...]]")
    group.add_option("-l", "--list", dest = "list", help = htxt["--list"], metavar = "CATEGORY")
    group.add_option("-s", "--sort", action = "store", dest = "sort", help = htxt["--sort"])
    group.add_option("-V", "--version", action = "store_true", dest = "version", help = htxt["--version"])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Other options", "Options that does not fit in any other option group and is usually used together with other options.")
    group.add_option("-D", "--destination", dest = "dest", help = htxt["--destination"], metavar = "VALUE")
    group.add_option("-O", "--score", dest = "score", help = htxt["--score"], metavar = "VALUE")
    group.add_option("-P", "--profile", dest = "profile", help = htxt["--profile"], metavar = "NAME")
    group.add_option("-F", "--force", action = "store_true", dest = "force", help = htxt["--force"])
    group.add_option("-p", "--pretend", action = "store_true", dest = "pretend", help = htxt["--pretend"])
    group.add_option("-y", "--days-ago", type = "int", dest = "daysago", help = htxt["--days-ago"], metavar = "DAYS")
    parser.add_option_group(group)
    
    return parser.parse_args()[0]

# Prints version number, licence and authors with email.
def version():
    print NAME,VERSION,'\n',LICENCE,'\n\nWritten by: ',AUTHORS,EMAIL
    return

# check if item exists in a category
def title_exists(db, cat, item):
    cursor = dbexec(db, "SELECT * FROM item WHERE title = '%s' AND cat = '%s'" % (item, cat), None, False)
    if len(cursor.fetchall()) > 0:
        return True
    return False

# Internal function to check for already existing items.
def id_exists(db, id):
    if not is_valid_id(id):
        text_error(ERROR['bad_id'] % c(id))
        sys.exit(1);

    cursor = dbexec(db, "SELECT * FROM item WHERE id = '%s'" % str(id), None, False)
    if len(cursor.fetchall()) > 0:
        return True
    return False
    
# Internal function to check for already existing items.
def get_title_from_id(db, id):
    if not is_valid_id(id):
        text_error(ERROR['bad_id'] % c(id))
        sys.exit(1);

    cursor = dbexec(db, "SELECT title FROM item WHERE id = '%s'" % id, None, False)
    res = cursor.fetchall()
    if len(res) > 0:
        return res[0][0]
    text_error(ERROR["item"] % c(id)) 
    sys.exit(1)

def get_category_from_title(db, config, title):
    cursor = dbexec(db, "SELECT cat FROM item WHERE title = '%s'" % format_text_in(title), None, False)
    res = cursor.fetchall()
    if len(res) > 0:
        return res[0][0]
    text_error(ERROR["notitle"] % c(title))
    sys.exit(1)

'''
# same thing, though if multiple items with the same title exists, from category may be
# selected when using this function
def get_category_from_id(db, config, id):
    return get_category_from_title(db, config, get_title_from_id(db, config, id))
'''
    
# Get the category of a title with a certain ID.
def get_category_from_id(db, config, id):
    cursor = dbexec(db, "SELECT cat FROM item WHERE id = '%s'" % id, None, False)
    res = cursor.fetchall()
    if len(res) > 0:
        return res[0][0]
    text_error(ERROR["item"] % c(id))
    sys.exit(1)

# Internal function to check for already existing items.
def item_exists(db, item):
    cursor = dbexec(db, "SELECT * FROM item WHERE title = '%s'" % item, None, False)
    if len(cursor.fetchall()) > 0:
        return True
    return False

# get the duplicate policy for a certain category
def get_duplicate_policy(config, cat):
    if not cat is None and ("duplicates." + cat) in config.keys():
        return config["duplicates." + cat]

    elif ("defval.duplicates") in config.keys():
        return config["defval.duplicates"]
    return None

# replace occurances in text of dict items from dic
def replace_all(text, dic):
    for i, j in dic.iteritems():
        text = text.replace(i, j)
    return text

# Do an approximate string search using the Apse package.
def approxsearch(db, conf, edits, sstr):
    import Apse # for approximate searching
    reslist = []
    reps = {'.':' ', '_':' ', '-':' '}

    if edits is 0 and "find.edits" in conf.keys():
        edits = int(conf["find.edits"])
    
    if edits > 10:
        edits = 10
    elif edits < 0:
        edits = 0

    cursor = dbexec(db, "SELECT * FROM item", None, False)
    db = cursor.fetchall()

    for search in [sstr]:
        # allow at most 'edits' edits 
        ap = Apse.Approx(search.lower(), edit=edits)

        # messy, I know
        for key in db: 
            val = key[1]
            id = key[0]
            cat = key[3]
            val_orig = val.lower()
            fnd = bool(ap.match(val_orig))
            dst = ap.dist(val_orig)
            res = (id, val, dst, cat)

            if fnd and val not in reslist:
                reslist.append(res)

            # Try to match if we replace some characters.
            val_rep = replace_all(val.lower(), reps)
            fnd_rep = bool(ap.match(val_rep))
            dst_rep = ap.dist(val)
            res_rep = (id, val, dst_rep, cat)

            if not fnd and fnd_rep and val not in reslist:
                reslist.append(res_rep)

    if reslist != []:
        showcats = False
        if "find.showcats" in conf.keys() and conf["find.showcats"] == '1':
            showcats = True

        text_note("Match found. Best match at the top.\n")
        old_cat = None

        if showcats:
            reslist.sort(lambda x,y:cmp(x[3],y[3]))
            reslist.reverse()
        
        else:
            reslist.sort(lambda x,y:cmp(x[2],y[2]))
            reslist.reverse()

        for res in reslist:
            if showcats:
                if old_cat is None or res[3] != old_cat:
                    print
                    if misc.get('category'):
                        print format_category_out(res[3], conf)
                    old_cat = res[3]

            # Make titles aligned.
            spacer = ' '*(5 - len(str(res[0])))

            # Showing ID when listing is optional.
            if "general.showid" not in conf.keys() or not misc.get('id'):
                print res[1]
            
            elif conf["general.showid"] == '1':
                print "%s%s%s %s: %s" % (C['bold'], res[0], C['default'], spacer, format_text_out(res[1]))
    else:
        text_warning("No matches found!")
    return

# try to see if specified category is valid
def is_valid_category(cat):
    if not cat:
        return False
    notallowed = "\\'"
    for char in cat:
        if char in notallowed:
            return False
    return True

# try to see if specified ID, range, negative etc. is a valid ID
def is_valid_id(id):
    if id[0] is '%':
        if not is_valid_id_number(id[1:]):
            text_error(ERROR['bad_id'] % c(id))
            return False

    if '-' in id:
        idrange = id.split('-')
        if not is_valid_id_number(idrange[0]) or not is_valid_id_number(idrange[1]):
            text_error(ERROR['bad_range'] % c(id))
            return False

    elif not is_valid_id_number(id):
        text_error(ERROR['bad_id'] % c(id))
        return False
    return True

# single ID checked if it's a number (i.e. no range, negation etc.)
def is_valid_id_number(id):
    sid = None
    try:
        iid = int(id)
        sid = str(iid)
        if iid < 0:
            return False
    except:
        return False

    if sid != id:
        return False
    return True

# parse a specified config file
def parse_config(conffile):
    if not os.path.isfile(conffile):
        f = file(conffile, 'w')
        f.close()
        text_error(ERROR["conf"])
        sys.exit(1)

    _config = {}
    cp = ConfigParser.ConfigParser()
    cp.read(conffile)

    for sec in cp.sections():
        name = string.lower(sec)
        for opt in cp.options(sec):
            _config[name + "." + string.lower(opt)] = string.strip(cp.get(sec, opt))
    return _config

# Print a category description using bold and colors.
def format_category_out(category, config):
    if ("categories." + category) not in config.keys():
        text_error(ERROR["catdesc"] % c(category))
        sys.exit(1)

    color = ''
    if ("colors." + category) in config.keys():
        color = C[config["colors." + category]]

    elif "colors.defcol" in config.keys():
        color = C[config["colors.defcol"]]

    if misc.get('color'):
        return "  %s%s%s ('%s')%s\n" %(C["bold"], color, config["categories." + category], category, C["default"])
    return "  %s ('%s')\n" % (config["categories." + category],  category)

# List duplicates, all or in a specific categories.
def list_duplicates(db, conf, cats):
    # if comma separated, split and prepare the extra sql values
    sqlcat = ''
    if cats is not None:
        sqlcat = 'WHERE '
        # set up the WHERE sql thingie
        for cat in cats:
            # no dropping tables here kiddo
            if not is_valid_category(cat):
                text_error(ERROR['bad_cat'] % cat)
                continue
            sqlcat += "cat = '%s' OR " % cat
        # probably don't want the last ' OR ' anyway
        sqlcat = sqlcat[:-4]

    # fire up the main laseeer
    results = dbexec(db, "SELECT id, title, COUNT(title) FROM item %s GROUP BY title HAVING (COUNT(title) > 1)" % sqlcat, None, False).fetchall()
    if not results:
        text_note("No duplicates found in category '%s'." % c(cat))
        return
    
    # each item returned by that last query up there only returns one of the duplicate items,
    # so get all matching titles and print their IDs and categories
    for item in results:
        print
        text_note("%s entries found for '%s':" % (c(str(item[2])), c(item[1])))
        dupeids = dbexec(db, "SELECT id, cat FROM item WHERE title = '%s'" % item[1], None, False).fetchall()
        for id in dupeids:
            print "  ID '%s' in category '%s'" % (c(str(id[0])), c(id[1]))
    return

# prints names of the shown columns when listing if chosen to in config
def print_table_head(pid, pscore, cw):
    LABEL = ['TITLE', 'ID', 'SCORE']
    output = ''

    for i in range(3):
        cw[i] -= len(LABEL[i])
        if cw[i] % 2 != 0:
            cw[i] += 1

    for i in range(3):
        LABEL[i] = ' '*(cw[i]/2) + LABEL[i] + ' '*(cw[i]/2)

    if pid:
        output += LABEL[1][:-1] + '|'
    if pscore in [0, False]:
        output += LABEL[2] + ' |'
    output += LABEL[0]

    print output
    # sum of all label lengths
    print '-'*(sum([len(x) for x in LABEL]) + 2)
    return

# List either all categories or only the default category.
def list(db, config, category, dests = None):
    pnewline = misc.get('newline')
    pcolor = misc.get('color')
    pscore = misc.get('score')
    pcat = misc.get('category')
    pid = misc.get('id')

    if dests:
        dests = dests.split(',')

    # column width
    colw_score = 7
    colw_id = 5

    alldbs = get_all_categories(db)

    # Only print the category titles.
    if category == "titles":
        for title in alldbs:
            print format_category_out(title, config)
        return

    # might print on only one line if so choose
    newline = ", "
    if pnewline:
        newline = "\n"

    # List duplicates.
    if category == "dupe":
        list_duplicates(db, config, dests)
        return

    dbs = [category]
    if category == '%':  dbs = alldbs
    elif category and ',' in category: dbs = category.split(',')
    elif category == None: dbs = [config_value(config, "defval.list")]

    if not dbs[0]:
        text_error(ERROR['deflist'])
        return

    # only care if it's set and not 0, and if newline is not... newline, dont show the table
    if config_value(config, "general.showtable") and newline is '\n':
        colw_title = 0
        for category in dbs:
            dbsel = dbexec(db, "SELECT * FROM item WHERE cat = '%s'" % category, None, False).fetchall()
            for id, title, date, cat, score in dbsel:
                if len(title) > colw_title:
                    colw_title = len(title)
        print_table_head(pid, pscore, [colw_title, colw_id, colw_score])

    output = ''
    for category in dbs:
        if category not in alldbs:
            text_error(ERROR["emptycat"] % c(category))
            return

        dbsel = dbexec(db, "SELECT * FROM item WHERE cat = '"+category+"'", None, False).fetchall()

        # Sorting is optional.
        sortmethod = misc.get('sort')
        if not sortmethod: sortmethod = config_value(config, "sort." + category)
        if not sortmethod: sortmethod = config_value(config, "defval.sort")

        if sortmethod is not None:
            # Sort by specified method.
            if sortmethod == "title":
                dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (v.lower(),int(k),a,b,c))
            elif sortmethod == "id":
                dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (int(k),v,a,b,c))
            elif sortmethod == "time":
                dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (a,int(k),v,b,c))
            elif sortmethod == "score":
                dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (int(c),int(k),v,a,b))

        if pcat: 
            output += format_category_out(category, config)
        for id, title, date, cat, score in dbsel:
            if not is_young(date):
                continue

            # Make titles aligned.
            id = str(id)
            sid = ' '*(colw_id - len(id))
            sscore = ' '*(colw_score - len(str(score)))

            # uuh, you probably don't want to touch the next few lines; it -works-, okay?
            l1 = ['1', None, False]
            l2 = ['0', False]
            gscore = config_value(config, "general.showscore")
            if config_value(config, "general.showid") is '1' and pid:
                output += bold(id, pcolor) + sid + ': '

            # break it down: gscore is the CONFIG value that tells us to PRINT scores or not,
            # pscore is the COMMAND LINE value that tells us to NOT PRINT (double negative)
            #
            # the command line have higher priority than the config
            # remember: 'command' here is double negative, so NO is YES, ignorance is bliss, war is..., sorry
            # config + command = 
            #   NO   +    NO   = YES
            #   NO   +    YES  = NO
            #   YES  +    NO   = YES (not necessary, since config already sais 'print ahead, dude'
            #   YES  +    YES  = NO
            if gscore in l1 and pscore in l1 or gscore in l2 and pscore in l2:
                output += bold(str(score), pcolor) + sscore + ': '
            output += format_text_out(title) + newline

    output = output.strip()
    if len(output) is 0:
        text_note("Could not find any items matching your criterion.")
        return

    if output[-1] == ',':
        output = output[:-1]

    print output
    return

# sql friendly format
def format_text_in(title):
    import re
    title = re.sub('"', "&#34;", title)
    title = re.sub("'", "&#39;", title)
    return title

# sql unfriendly format
def format_text_out(title):
    import re
    title = re.sub("&#34;", '"', title)
    title = re.sub("&#39;", "'", title)
    return title

# if 'ident' is specified in the config, return its value
def config_value(config, ident):
    if ident in config.keys():
        return config[ident]
    return None

# return bold version of the text if not color is False
def bold(string, color = True):
    if color:
        return C['bold'] + string + C['default']
    return string

# return True if the difference between specified unix time and now is 
# less than 'daysago' specified in config. False otherwise
def is_young(date):
    if misc.get('daysago') is not 0:
        if int(time.time()) - int(date) > misc.get('daysago')*24*3600:
            return False
    return True

# figure out if an item-to-be-added is allowed in that category according to the category's policy
def enforce_duplicate_policy(db, config, name, category):
    dup = get_duplicate_policy(config, category)

    if dup == '0' and item_exists(db, name):
        existing_category = get_category_from_title(db, config, name)
        existing_duplicate = get_duplicate_policy(config, existing_category)
        if existing_duplicate not in ["1", "2"]:
            text_warning("Item already exists in category '%s'. Use (--force, -f) to add anyway." % c(existing_category))
            if not misc.get('force'):
                sys.exit(1)

    # need to check both
    if dup == '1' and title_exists(db, category, name):
        text_warning("Item already exists in category '%s'. Use (--force, -f) to add anyway." % c(category))
        if not misc.get('force'):
            sys.exit(1)
    return

# Add an item to the database.
def add(db, config, name, category, dbfile):
    if ("categories." + category) not in config.keys():
        text_error(ERROR["nocat"] % c(category))
        sys.exit(1)

    # make it sql friendly
    name = format_text_in(name)

    # check if it's allowed to be added to this category according to it's policy
    enforce_duplicate_policy(db, config, name, category)

    # time.time() returns float, so throw away the ms, then convert to string for writing
    date = str(int(time.time()))

    cursor = dbexec(db, "SELECT * FROM curid", None, False)
    id = cursor.fetchall()[0][0] + 1;

    # FIXME: AUTO_INCREMENT
    dbexec(db, "UPDATE curid SET id = id + 1", None, True)
    dbexec(db, "INSERT INTO item (id, title, date, cat) VALUES (%s, %s, %s, %s)", (id, name, date, category), True)

    print_info(config, 'add', (str(id), name, category, None))
    return

# see if we're only pretending to be mad
def pretend():
    return misc.get('pretend')

# Execute SQL statement.
def dbexec(db, template, values, volatile):
    # volatile is all UPDATE, INSERT etc., so if pretending, 
    # don't actually do anything, just look busy so the boss
    # won't thing something's up
    if volatile and pretend():
        return

    cursor = db.cursor()
    if values is None:
        cursor.execute(template)
    else:
        cursor.execute(template, values)
    return cursor

def db_backup(conf):
    text_note("Backing up database...")
    import commands

    username = config_value(conf, 'database.user')
    password = config_value(conf, 'database.pass')
    dbname = config_value(conf, 'database.name')
    commands.getstatusoutput('mysqldump -u %s -p%s %s | gzip -9 > %s.gz' % (username, password, dbname, DBBAK))
    text_note("Backup complete!")

    return

def db_restore(conf):
    text_note("Restoring database from backup...")
    if not pretend():
        import commands
        username = config_value(conf, 'database.user')
        password = config_value(conf, 'database.pass')
        dbname = config_value(conf, 'database.name')
        cmd = "gunzip -c %s.gz | mysql -u %s -p%s %s" % (DBBAK, username, password, dbname)
        retval = commands.getstatusoutput(cmd)
    text_note("Backup restored!")

    return


# Delete an item from the database.
def delete(db, conf, ids, dbfile):
    alldbs = get_all_categories(db)
    ids = str(ids).split(',')

    # backup db if something goes wrong
    db_backup(conf)

    for id in ids:
        # works for non-range IDs too
        if not is_valid_id(id):
            continue

        # hack to get the for loop to go once if no range was used
        idrange = [id, id]
        if '-' in id:
            idrange = id.split('-')

        # only happens once if not a range
        for i in range(int(idrange[0]), int(idrange[1]) + 1):
            delete_id(db, conf, str(i))
    return

def delete_id(db, config, id):
    result = dbexec(db, "SELECT * FROM item WHERE id = '%s'" % id, None, False).fetchall()

    # doesn't exist
    if len(result) == 0:
        text_warning(ERROR["item"] % c(id))
        return

    cat = result[0][3]
    title = format_text_out(result[0][1])
    dbexec(db, "DELETE FROM item WHERE id = '%s'" % id, None, True)

    print_info(config, 'delete', (id, title, cat, result[0][2]))

    return

def print_info(config, type, values):
    style = config_value(config, "general.printstyle")
    if type is 'delete':
        words = ('Deleted', 'from', 'red', True)
    elif type is 'add':
        words = ('Added', 'to', 'green', True)
    elif type is 'move':
        words = ('Moved', "from '%s' to" % c(values[4]), 'green', True)

    # default value
    if not style or style is '0':
        text_info(text_color(words[0], words[2], words[3]))
        text_info("ID       : %s" % c(values[0]))
        text_info("Title    : %s" % c(values[1]))
        text_info("Category : %s" % c(values[2]))
        if values[3]:
            text_info("Age      : %s" % format_time_passed(values[3]))
        print

    elif style is '1':
        text_info("%s item with ID '%s' and title '%s' %s category '%s'" % \
            (words[0], c(values[0]), c(str(values[1])), words[1], c(values[2])))
        if values[3]:
            text_info("It was in that category for %s" % format_time_passed(values[3]))

    elif style is '2':
        text_info("%s '%s' '%s' %s '%s'" % (words[0], c(values[0]), c(str(values[1])), words[1], c(values[2])))
        if values[3]:
            text_info("Age was %s" % format_time_passed(values[3]))

    elif style is '3':
        text_info("%s '%s' '%s' %s '%s'" % (words[0], c(values[0]), c(str(values[1])), words[1], c(values[2])))

    else:
        text_info("%s '%s'" % (words[0], c(str(values[1]))))
        
    return

# friendly output
def format_time_passed(date):
    date = time_passed(date)
    return "%s years, %s days, %s hours, %s minutes and %s seconds." % \
       (c(date[0]), c(date[1]), c(date[2]), c(date[3]), c(date[4]))


# get all category names
def get_all_categories(db):
    cursor = dbexec(db, "SELECT DISTINCT cat FROM item", None, False)
    return [x[0] for x in cursor.fetchall()]

# calculate how long time has passed since a certain date and return
# a tuple on the form (years, days, hours, minutes, seconds)
def time_passed(date):
    date = int(time.time()- int(date))
    return (str(date/60/60/24/365), str(date/60/60/24 % 365), \
        str(date/60/60 % 24), str(date/60 % 60), str(date % 60))

# print a notice (like 'Deleted item blabla' or 'Added item blabla')
def text_note(text):
    text = format_text_out(text)
    if misc.get('verbose') is not 0:
        if misc.get('color'):
            print "%s%sNote: %s%s" % (C["bold"], C["green"], C["default"], text)
        else:
            print "Note: " + text
    return

def text_info(text):
    text = format_text_out(text)
    print text
    return

# print and error (like 'No item with ID blalba')
def text_error(text):
    text = format_text_out(text)
    if misc.get('verbose') is not 0:
        if misc.get('color'):
            print "%s%sError: %s%s" % (C["bold"], C["red"], C["default"], text)
        else:
            print "Error: " + text
    return

# print a warning. Sort of the same as error, duh, should remove one of them
def text_warning(text):
    text = format_text_out(text)
    if misc.get('verbose') is not 0:
        if misc.get('color'):
            print "%s%sWarning: %s%s" % (C["bold"], C["yellow"], C["default"], text)
        else:
            print "Warning: " + text
    return

def text_color(text, color, bold = False):
    if not bold:
        return C[color] + text + C["default"]
    return C[color] + C["bold"] + text + C["default"]

# Change the value of an item with ID 'id'.
def change(db, conf, id, val_orig, dbfile):
    import re
    # Find all '%([0-9]+)' in 'val'.
    id = id.split(',')
    res = re.findall(r'\%\(([0-9]+|#)\)', format_text_out(val_orig))

    rids = []
    for k, i in enumerate(id):
        if not id_exists(db, i):
            text_warning(ERROR["item"] % i)
            rids = [k] + rids
    for j in rids:
        del id[j]

    # so the user had some %(blabal) in their query, *sigh*, do some search and replace
    if res:
        for i in id:
            val = val_orig
            for v in res:
                # This means "if %(#), do this".
                if not cmp(v, '#'):
                    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None, False)
                    result = cursor.fetchall()
                    rval = result[0][1]

                else:
                    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+v+"'", None, False)
                    result = cursor.fetchall()
                    rval = result[0][1]

                p = re.compile('\%\(' + v + '\)')
                val = p.sub(rval, val)

            # sql friendly is your friend
            val = format_text_in(val)
            cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None, False)
            result = cursor.fetchall()
            old = result[0][1]
            dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None, True)

            text_note("Changed item with ID '%s' from '%s' to '%s'." % (c(i), c(format_text_out(old)), c(format_text_out(val))))

    # fuck yeah, no search and replace needed, just do the thing
    else:
        for i in id:
            val = format_text_in(val_orig)
            cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None, False)
            result = cursor.fetchall()
            old = result[0][1]
            dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None, True)

            text_note("Changed item with ID '%s' from '%s' to '%s'." % (c(i), c(format_text_out(old)), c(format_text_out(val))))
    return

# Move an item with ID 'id' to a new category.
def move(db, conf, id, newcat, dbfile):
    if not ("categories." + newcat) in conf.keys():
        text_error(ERROR["nocat"] % c(newcat))
        sys.exit(1)

    newdate = str(int(time.time()))
    enforce_duplicate_policy(db, conf, get_title_from_id(db, id), newcat)

    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None, False)
    result = cursor.fetchall()
    if len(result) == 0:
        text_error(ERROR["item"] % c(id))
        sys.exit(1)

    dbexec(db, "UPDATE item SET cat = '%s' WHERE id = '%s'" % (newcat, str(id)), None, True)
    dbexec(db, "UPDATE item SET date = '%s' WHERE id = '%s'" % (newdate, str(id)), None, True)
    title = result[0][1]
    d = result[0][3]

    print_info(conf, 'move', (id, format_text_out(title), newcat, result[0][2], d))
    #text_note("Moved item with ID '%s' and title '%s' from category '%s' to '%s'." % (c(id), c(format_text_out(title)), c(d), c(newcat)))
    #text_note(format_time_passed(result[0][2]))
    return

# colorize some random text if told to in the config
def c(text):
    if misc.get('color'):
        return C['g'] + text + C['d']
    return text

# internal function used by info() a heck of a lot to get info from -one- ID
def get_info_from_id(db, id, rangewarn = None):
    result = dbexec(db, "SELECT * FROM item WHERE id = '%s'" % str(id), None, False).fetchall()
    if not result:
        if rangewarn:
            text_error(ERROR["item"] % c(id))
        return

    result = result[0]
    # add the columns needed for printing and rearange them a bit for fun and profit
    d = time.gmtime(int(result[2]))
    date_added = '%d-%d-%d, %d:%d:%d' % (d[0], d[1], d[2], d[3], d[4], d[5])
    result = [
        result[0], # id
        result[4], # score
        format_text_out(result[1]), # title
        result[3], # category
        date_added, # added
        time_passed(result[2]) # time in category
    ]
    return result

# Prints formated table with info about items with specified IDs.
def info(db, conf, ids, dests = None):
    # [id, score, title, category, date_added, time_in_category]
    strlens = [1,1,1,1,1,1]
    items = []
    skip = []
    ids = ids.split(',')
    if dests is not None:
        dests = dests.split(',')

    # should we warn if ID not found in range?
    rangewarn = config_value(conf, "general.inforangewarn")

    # go through all specified IDs
    for id in ids:
        # works for non-range IDs too
        if not is_valid_id(id):
            continue

        # skip using '%'
        if id[0] is '%':
            skip.append(id[1:])
            continue

        # warn?
        inrange = False
        if '-' in str(id):
            inrange = True
        rangewarn = rangewarn is '1' and inrange

        # hack to get the for loop to go once if no range was used
        idrange = [id, id]
        if '-' in id:
            idrange = id.split('-')

        # only happens once if not a range
        for i in range(int(idrange[0]), int(idrange[1]) + 1):
            result = get_info_from_id(db, str(i), rangewarn)
            # like bad_id or something
            if not result:
                continue
            items.append(result)

    # found nothin', error/warning/whatever already shown if so
    if not items:
        return

    # calculate each columns max width if not in skip list
    for item in items:
        # this ID was specified with a '%' before it, so continue
        if str(item[0]) in skip:
            continue
        # if destination cateogries are specified, and this item's not in it, continue
        if dests and item[3] not in dests:
            continue
        for i in range(len(strlens)):
            if len(str(item[i])) > strlens[i]:
                strlens[i] = len(str(item[i]))

    # calculate spaces between column headers and print them
    width = 0
    labels = ['ID  ', 'SCORE  ', 'TITLE  ', 'CATEGORY  ', 'DATE ADDED  ', 'TIME IN CATEGORY  ']
    for i in range(len(labels)):
        spaces = max(strlens[i], len(labels[i])) - len(labels[i]) + 1
        width += spaces + len(labels[i])
        sys.stdout.write(labels[i] + ' '*spaces + '| ')
    print '\n' + '-'*width

    # calculate spaces between column items and print them
    for item in items:
        # this ID was specified with a '%' before it, so continue
        if str(item[0]) in skip:
            continue
        # if destination cateogries are specified, and this item's not in it, continue
        if dests and item[3] not in dests:
            continue
        for i in range(len(strlens) - 1):
            spaces = max(strlens[i] - len(str(item[i])), len(labels[i]) - len(str(item[i]))) + 1
            sys.stdout.write('%s%s| ' % (item[i], ' '*spaces))
        # this is the time it's been in this category
        print '%sy %sd %sh %sm %ss' % (item[5][0], item[5][1], item[5][2], item[5][3], item[5][4])
    print '-'*width
    return

# only really used when creating a new category as of writing. Saves the config, duh
def save_config(config, configfile):
    if pretend():
        return

    cf = open(configfile, 'wb')
    for sec in config.sections():
        name = string.lower(sec)
        cf.write("\n[" + name + "]\n")
        for opt in config.options(sec):
            cf.write(string.lower(opt) + ": " + string.strip(config.get(sec, opt)) + "\n")

    cf.close()
    return

# create a new category from command line
def create_new_category(configfile, title, id):
    sections = ["categories", "defval", "general"]

    config = ConfigParser.ConfigParser()
    config.read(configfile)

    if config.has_option("categories", id):
        text_error(ERROR['dupe_cat'] % (c(id), c(title)))
        sys.exit(1)

    for section in sections:
        if not config.has_section(section):
            config.add_section(section)

    config.set("categories", id, title)
    # some standard options to be set for the new category
    confs = [
        ("move", id, id), 
        ("defval", "list", id), 
        ("defval", "add", id),
        ("defval", "sort", "title"),
        ("defval", "color", "green"),
        ("defval", "duplicates", 0),
        ("general", "showid", 1)
    ]

    # add if not already in it
    for conf in confs:
        if not config.has_option(conf[0], conf[1]):
            config.set(conf[0], conf[1], conf[2])

    save_config(config, configfile)
    text_note("Added category '%s' with title '%s'." % (c(id), c(title)))
    return

# assign a score to and item
def set_score(db, dbfile, config, id, score):
    dbexec(db, "UPDATE item SET score = '"+score+"' WHERE id = '"+id+"'", None, True)
    title = get_title_from_id(db, id)
    text_note("Assigned score '%s' to item with ID '%s' and value '%s'." % (c(score), c(id), c(format_text_out(title))))
    return

# Handle command line arguments.
def main():
    # Check if config and database files exists and are read- and writeable.
    if not os.path.exists(CONFIG):
        text_error(ERROR["dbcat"])
        sys.exit(1)

    # Read the config file.
    config = parse_config(CONFIG)

    db = MySQLdb.connect(
        config["database.host"], 
        config["database.user"], 
        config["database.pass"], 
        config["database.name"])

    configfile = CONFIG
    dbfile = DB
    opts = parseargs()

    if opts.pretend is True:
        misc.set('pretend', True)

    if opts.version is True:
        version()
        return

    if opts.profile is not None:
        profile = opts.profile
        config = parse_config(ALTRC + profile)
        configfile = ALTRC + profile
        dbfile = ALTDB + profile
        db = changedb(config, dbfile)

    if opts.daysago is not None:
        misc.set('daysago', opts.daysago)

    if opts.noid is True:
        misc.set('id', False)

    if opts.printcolor is False:
        misc.set('color', False)

    if opts.printnewline is False:
        misc.set('newline', False)

    if opts.printcat is False:
        misc.set('category', False)

    if opts.hide is True:
        misc.set('id', False)
        misc.set('color', False)
        misc.set('newline', False)
        misc.set('category', False)

    if opts.verbose is not None:
        misc.set('verbose', opts.verbose)

    if opts.force is True:
        misc.set('force', True)

    if opts.sort is not None:
        misc.set('sort', opts.sort)
        
    # Will always either be True, False or None, even if not specified.
    misc.set('score', opts.noscore)

    if opts.edits is not None:
        misc.set('edits', opts.edits)

    # Options that do things comes last.
    if opts.addcat is not None:
        if opts.dest is None:
            text_error(ERROR["destcat"])
            sys.exit(1)
        create_new_category(configfile, opts.addcat, opts.dest)
        return

    if opts.restore is not None:
        db_restore(config)
        return

    if opts.find is not None:
        approxsearch(db, config, misc.get('edits'), opts.find)
        return

    if opts.move is not None:
        id = str(opts.move)
        if opts.dest is not None:
            newcat = opts.dest
            move(db, config, id, newcat, dbfile)
            return

        # User didn't specify what category to move to, try to use the default value.
        curcat = get_category_from_id(db, config, id)

        # Try default for current category.
        newcat = "move." + curcat
        if not newcat in config.keys():
            # Otherwise try to use default for all categories.
            if not "defval.move" in config.keys():
                text_error(ERROR["destdefcat"])
                sys.exit(1)
            else: newcat = config["defval.move"]
        else: newcat = config[newcat]
        move(db, config, id, newcat, dbfile)
        return

    if opts.change is not None:
        if opts.dest is None:
            text_error(ERROR["destchg"])
            sys.exit(1)

        change(db, config, opts.change, opts.dest, dbfile)
        return

    if opts.delete is not None:
        delete(db, config, opts.delete, dbfile)
        return

    if opts.info is not None:
        info(db, config, opts.info, opts.dest)
        return

    if opts.add is not None:
        title = opts.add

        if opts.dest is not None:
            category = opts.dest
        else:
            if not "defval.add" in config.keys():
                text_error(ERROR["defadd"])
                sys.exit(1)
            category = config["defval.add"]

        add(db, config, title, category, dbfile)
        return

    if opts.score is not None:
        if opts.dest is None:
            text_error(ERROR["destscore"])
            sys.exit(1)

        if not id_exists(db, opts.dest):
            text_error(ERROR["item"] % c(opts.dest))
            sys.exit(1)

        set_score(db, dbfile, config, opts.dest, opts.score)
        return
        
    # Nothing else was done, so list a category.
    category = None
    if opts.list is not None:
        category = opts.list
    list(db, config, category, opts.dest)
    return

# call your mama and tell her how great you are!
if __name__ == "__main__":
    main()
    sys.exit()
