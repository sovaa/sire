#!/usr/bin/python

import string, sys, getopt, os, re, ConfigParser
import Apse # for approximate searching

HOME = os.path.expanduser("~")
PATH = HOME + "/.sire/"
CONFIG = PATH + "/sirerc"
DB = PATH + "/siredb"

NAME = "sire"
VERSION = "0.1.6"
AUTHORS = "Oscar Eriksson"
EMAIL = "(oscar.eriks@gmail.com)"
LICENCE = '''License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to move and redistribute it.
There is NO WARRANTY, to the extent permitted by law.'''

C = { 
    'default' : "\033[0m",
    'd'       : "\033[0m",
    'bold'    : "\033[1m",
    'b'       : "\033[1m",
    'red'     : "\033[31m",
    'green'   : "\033[32m",
    'g'   : "\033[32m",
    'yellow'  : "\033[33m",
    'blue'    : "\033[34m",
    'magenta' : "\033[35m",
    'm'       : "\033[35m",
    'cyan'    : "\033[36m",
}

# Define arguemnts.
opts, args = getopt.getopt(
    sys.argv[1:], # Arguements from commandline.
    'lhcvfa:d:m:',  # Short arguments.
    ['list', 'change', 'add=', 'move=', 'delete=', 'find', 'help', 'version'] # Long arguments.
)





def usage():
    print '''Usage: [OPTION] [ARGUMENTS]
    --list, -l [catagory]
    --add, -a <value> [catagory]
    --delete, -d <ID1[, ID2[, ...]]>
    --find, -f <value1[, value2[, ...]]>
    --move, -m <ID1> <ID2>
    --change, -c <ID> <new value>
    --help, -h
    --version, -v

For examples, see README.

Files:
    Configuration:
    ~/.sire/sirerc

    Database:
    ~/.sire/siredb
'''





# Prints version number, licence and authors with email.
def version():
    print NAME,VERSION,'\n',LICENCE,'\n\nWritten by: ',AUTHORS,EMAIL





# Internal function to check for already existing items.
def itemexists(db, item):
    for key in db.keys():
        for val in db[key].values():
            if val == item:
                return True

    return False





def replace_all(text, dic):
    for i, j in dic.iteritems():
        text = text.replace(i, j)
    
    return text





# Do an approximate string search using the Apse package.
def approxsearch(db, conf, sstr):
    reslist = []
    reps = {'.':' ', '_':' ', '-':' '}

    if "find.edits" in conf.keys():
	edits = int(conf["find.edits"])
	if edits > 10:
	    edits = 10

	elif edits < 0:
	    edits = 0

    else:
	edits = 0

    for str in sstr:
        # allow at most 'edits' edits 
        ap = Apse.Approx(str.lower(), edit=edits)

        for key in db.keys():
            for (id, val) in db[key].items():
                val_orig = val.lower()
                fnd = bool(ap.match(val_orig))
		dst = ap.dist(val_orig)
		res = (id, "%s" % val, ("%d", dst), key)

                if fnd and val not in reslist:
		    reslist.append(res)

		# Try to match if we replace some characters.
		val_rep = replace_all(val.lower(), reps)
                fnd_rep = bool(ap.match(val_rep))
		dst_rep = ap.dist(val)
		res_rep = (id, "%s" % val, ("%d", dst_rep), key)

	        if not fnd and fnd_rep and val not in reslist:
		    reslist.append(res_rep)

    if reslist != []:
	showcats = False
	if "find.showcats" in conf.keys() and conf["find.showcats"] == '1':
	    showcats = True

        print "Match found. Best match at the top.\n"
	old_cat = None

	if showcats:
            reslist.sort(lambda x,y:cmp(x[3],y[3]))
	    reslist.reverse()
	
	else:
            reslist.sort(lambda x,y:cmp(x[2],y[2]))
	    reslist.reverse()

        for res in reslist:
	    if showcats:
		if old_cat is None or res[3] != old_cat:
		    print
		    printcatagory(res[3], conf)
		    old_cat = res[3]

            # Make titles aligned.
            spacer = ''
            for i in range(0, 3 - len(res[0])):
                spacer += ' '

            # Showing ID when listing is optional.
            if "general.showid" not in conf.keys():
                print res[1]
            
            elif conf["general.showid"] == '1':
                print C['bold'] + res[0] + C['default'], spacer + ':', res[1]

    else:
        print "No matches found!"





def parseconfig(conffile):
    _config = {}
    cp = ConfigParser.ConfigParser()
    cp.read(conffile)
    for sec in cp.sections():
        name = string.lower(sec)
        for opt in cp.options(sec):
            _config[name + "." + string.lower(opt)] = string.strip(cp.get(sec, opt))
    return _config





# Print a catagory (status) description using bold and colors.
def printcatagory(catagory, config):
    if ("catagories." + catagory) not in config.keys():
        print "There is no Catagory description for catagory '" + catagory + "'!"
        sys.exit(1)

    if not ("colors." + catagory) in config.keys():
        if not "colors.defcol" in config.keys():
            color = ''

        else:
            color = C[config["colors.defcol"]]
    else:
        color = C[config["colors." + catagory]]

    print C["bold"], color, config["catagories." + catagory], "('" + catagory + "')", C["default"]





# Read the database.
# FIXME: I don't want to load a 500MB file each time I wan't to check what I can watch.
def parsedb(dbfile):
    db = {}
    id = 0
    f = file(dbfile, 'r')
    for line in f.readlines():
        parts = line.split(":", 2)
        parts[2] = parts[2][:-1]

        if not db.has_key(parts[0]):
            db[parts[0]] = {parts[1] : parts[2]}

        else:
            db[parts[0]][parts[1]] = parts[2]

        id += 1

    f.close()
    return db





# List duplicates, all or in a specific catagory.
# FIXME: O(n^4) complexity ffs
def listdupes(db, conf, cat):
    dupeids = []

    # If no catagory is specified, go through every catagory.
    if cat is None:
        for d in db:
            dvals = db[d].values()
            dkeys = db[d].keys()

            while dvals != []:
                dval = dvals.pop()
                dkey = dkeys.pop()
    
                for dd in db:
                    if d is dd:
                        continue
    
                    ddvals = db[dd].values()
                    ddkeys = db[dd].keys()
    
                    while ddvals != []:
                        ddval = ddvals.pop()
                        ddkey = ddkeys.pop()
    
                        if dval == ddval:
                            if dkey not in dupeids:
                                dupeids.append(dkey)
                                print dkey, dval, "(%s)" % d

                            if ddkey not in dupeids:
                                dupeids.append(ddkey)
                                print ddkey, ddval, "(%s)" % dd

    elif not cat in db.keys():
        print "Catagory does not exist."
        sys.exit(1)

    # Use specified catagory.
    else:
        dvals = db[cat].values()
        dkeys = db[cat].keys()

        while dvals != []:
            dval = dvals.pop()
            dkey = dkeys.pop()

            for (k, v) in zip(dkeys, dvals):
                if dval == v:
                    dupeids.append(dval)
                    print dkey, dval, "(%s)" % cat
                    print k, v, "(%s)" % cat
                    print


    if dupeids == []:
        print "No duplicates found."





# List either all catagories or only the default catagory.
def list(db, config, catagory):
    # Nothing in database.
    if db == {}:
        print "Empty."
        sys.exit()

    # Only print the catagory titles.
    if catagory == "titles":
        for title in db.keys():
            printcatagory(title, config)

        sys.exit()

    # List duplicates.
    if catagory == "dupe":
        if len(sys.argv) < 4:
            listdupes(db, config, None)

        else:
            listdupes(db, config, sys.argv[3])

        sys.exit()

    if   catagory == "all" : dbs = db.keys()
    elif catagory == None  : dbs = config["defval.list"]
    else                   : dbs = [catagory]

    for catagory in dbs:
        if catagory not in db.keys():
            print "Empty catagory."
            sys.exit(1)

        dbsel = db[catagory].items()

        # Sorting is optional.
        if ("sort." + catagory) in config.keys():
            sortmethod = config["sort." + catagory]

        elif "defval.sort" in config.keys():
            sortmethod = config["defval.sort"]

        else:
            sortmethod = False

        if sortmethod is not False:
            # Sort by specified method.
            if sortmethod == "title":
                dbsel = sorted(db[catagory].items(), key=lambda (k,v): (v.lower(),k))
            elif sortmethod == "id":
                dbsel = sorted(db[catagory].items(), key=lambda (k,v): (int(k),v))
            else:
                dbsel = db[catagory].items()

        printcatagory(catagory, config)
        for id, title in dbsel:
            # Make titles aligned.
            spacer = ''
            for i in range(0, 3 - len(id)):
                spacer += ' '

            # Showing ID when listing is optional.
            if "general.showid" not in config.keys():
                print title
            
            elif config["general.showid"] == '1':
                print C['bold'] + id + C['default'], spacer + ':', title

            else:
                print title
 
        # For newline separator between items of different statuses.
        print





# Add an item to the database.
def add(db, config, name, catagory):
    if ("catagories." + catagory) not in config.keys():
        print "Specified catagory does not exist."
        sys.exit(1)

    l = []
    for k, v in db.iteritems():
        l += v.keys()

    id = "0"
    for i in l:
        if int(i) > int(id):
            id = str(i)

    id = str(int(id) + 1)

    f = open(DB, 'a')
    f.write(catagory + ":" + id + ":" + name + '\n')
    f.close()

    if itemexists(db, name):
        print C["bold"] + C["red"] + "Warning:" + C["default"], "Item already exists in catagory '" + catagory + "'."

    print "Saved '" + name + "' with id '" + id + "'."





# Delete an item from the database.
def delete(db, ids):
    for id in ids:
        deleted = False
        for d in db:
            if db[d].has_key(id):
                del db[d][id]
                deleted = True
		break

        if deleted:
            print "Deleted item with ID '" + C['g'] + id + C['d'] + "' and title '" +  \
		C['g'] + db[d][id] + C['d'] + "' from catagory '" + C['g'] + d + C['d'] + "'."
        else:
            print C["bold"] + C["red"] + "Error: " + C["default"] + "Item with ID " + id + " not found."

    savedb(db)





# Save a changed database.
def savedb(db):
    f = open(DB, 'w')
    for d in db:
        for id in db[d]:
            f.write(d + ":" + id + ":" + db[d][id] + "\n")

    f.close()





# Change the value of an item with ID 'id'.
def change(db, conf, id, val_orig):
    # Find all '%([0-9+)' in 'val'.
    id = id.split(',')
    res = re.findall(r'\%\(([0-9]+|#)\)', val_orig)

    if res != []:
	for i in id:
	    val = val_orig
	    for v in res:
		if not cmp(v, '#'):
		    rval = db[getcat(db, i)][i]

		else:
		    rval = db[getcat(db, v)][v]

		p = re.compile('\%\(' + v + '\)')
		val = p.sub(rval, val)

	    cat = getcat(db, i)
	    old = db[cat][i]

	    print "Changed item '"+C['b']+i+C['d']+"' from '"+C['m']+old+C['d']+"' to '" + C['m']+val+C['d']+"'."
            db[cat][i] = val

    else:
	for i in id:
	    val = val_orig
	    cat = getcat(db, i)
	    old = db[cat][i]

	    print "Changed item '"+C['b']+i+C['d']+"' from '"+C['m']+old+C['d']+"' to '" + C['m']+val+C['d']+"'."
            db[cat][i] = val

    savedb(db)




# Move an item with ID 'id' to a new catagory.
def move(db, conf, id, newcat):
    found = False
    for d in db:
        if id in db[d].keys():
            found = True
            break;

    if not found:
        print "no no"
        sys.exit(1)

    if not ("catagories." + newcat) in conf.keys():
        print "No such catagory ('" + newcat + "'). Add it in the sirerc first."
        sys.exit(1)

    title = db[d][id]

    if db.has_key(newcat):
        db[newcat][id] = title
    else:
        db[newcat] = dict([(id, title)])

    del db[d][id]

    print "Moved item with ID '"+id+"' from '"+d+"' to '"+newcat+"'."

    savedb(db)





# Get the catagory of a title with a certain ID.
def getcat(db, id):
    for d in db:
        if id in db[d].keys():
            return d
    
    # We didn't find it.
    print "Catagory of title with ID '"+id+"' not found."
    sys.exit(1)





# Handle command line arguments.
def main():
    # Check if config and database files exists and are read- and writeable.
    if not os.path.exists(DB) or not os.path.exists(CONFIG):
        print "Database and/or config file not found. Should be in ~/.sire/!"
        sys.exit(1)

    # First read the database from the file.
    db = parsedb(DB)

    # Read the config file.
    config = parseconfig(CONFIG)

    # If no argument given, list items of default catagory.
    if len(sys.argv) == 1:
        list(db, config, None)
        sys.exit()

    # What to do with the different arguments.
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()

        elif o in ("-l", "--list"):
            if len(sys.argv) == 2:
                # Use default catagory first.
                catagory = config["defval.list"]
                list(db, config, catagory)
                sys.exit()

            catagory = sys.argv[2]
            list(db, config, catagory)

        elif o in ("-a", "--add"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

            # Use default catagory first.
            catagory = config["defval.add"]

            if len(sys.argv) == 4:
                catagory = sys.argv[3]

            title = sys.argv[2]
            add(db, config, title, catagory)

        elif o in ("-d", "--delete"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)
    
            id = sys.argv[2:]
            delete(db, id)

	elif o in ("-c", "--change"):
	    if len(sys.argv) < 4:
		usage()
		sys.exit(1)

	    id = sys.argv[2]
	    val = sys.argv[3]

	    change(db, config, id, val)
	    

        elif o in ("-m", "--move"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)
    
            id = sys.argv[2]
            
            # User didn't specify what catagory to move to, try to use the default value.
            if len(sys.argv) < 4:
                curcat = getcat(db, id)

                # Try default for current catagory.
                newcat = "defval.move-" + curcat
                if not newcat in config.keys():
                    # Otherwise try to use default for all catagories.
                    if not "defval.move" in config.keys():
                        print "Need to specify catagory, default catagory not found."
                        sys.exit(1)

                    else:
                        newcat = config["defval.move"]
                else:
                    newcat = config[newcat]

            # User specified catagory.
            else:
                newcat = sys.argv[3]

            move(db, config, id, newcat)

        elif o in ("-f", "--find"):
            if len(sys.argv) < 3:
                usage()
                sys.exit(1)

            approxsearch(db, config, sys.argv[2:])


        elif o in ("-v", "--version"):
            version()
            sys.exit()

        else:
            usage()
            sys.exit(1)





# Call main().
if __name__ == "__main__":
    main()
    sys.exit()
