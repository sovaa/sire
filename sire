#!/usr/bin/python

#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


import string, sys, getopt, os, ConfigParser, time, shutil
import Apse # for approximate searching
import MySQLdb # database
from optparse import OptionParser
from optparse import OptionGroup

HOME = os.path.expanduser("~")
PATH = HOME + "/.sire/"
CONFIG = PATH + "/sirerc"
DB = PATH + "/siredb"
ALTDB = PATH + "/altdb/"
ALTRC = PATH + "/altrc/"

NAME = "sire"
VERSION = "0.2.1"
AUTHORS = "Oscar Eriksson"
EMAIL = "(oscar.eriks@gmail.com)"
LICENCE = '''License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to move and redistribute it.
There is NO WARRANTY, to the extent permitted by law.'''

C = { 
    'default' : "\033[0m",
    'd'       : "\033[0m",
    'bold'    : "\033[1m",
    'b'       : "\033[1m",
    'red'     : "\033[31m",
    'green'   : "\033[32m",
    'g'       : "\033[32m",
    'yellow'  : "\033[33m",
    'blue'    : "\033[34m",
    'magenta' : "\033[35m",
    'm'       : "\033[35m",
    'cyan'    : "\033[36m",
}

ERROR = {
    "item":        "Item with ID '%s' does not exist.",
    "dest":        "Need destination. Use --destination, -d.",
    "destcat":     "Need to specify a category ID. Specify it with --destination, -D.",
    "destchg":     "No change-to value specified. Specify it using --destination, -D.",
    "destscore":   "Need an item to assign the score to. Use --destination, -D.",
    "destdefcat":  "Need to specify category, default category not found. Use --destination, -D or edit your config file.", 
    "conf":        "Config file didn't exist. I created it for you. Populate it before continuing.",
    "catdesc":     "There is no category description for category '%s'.",
    "nocat":       "Category '%s' does not exist.",
    "notitle":     "There is no item with title '%s'.",
    "nodb":        "Database didn't exist. I created it for you.",
    "emptydb":     "Your database is empty.",
    "emptycat":    "Empty category '%s'.",
    "dbcat":       "Database and/or config file not found. Should be in '~/.sire/'.",
    "defadd":      "defval.add not specified in config file, and no category specified on command line when adding."
}    

class miscfunctions:
    def __init__(self):
	self.info = {
            'force': False, 
            'verbose': 1, 
            'color': True, 
            'id': True, 
            'newline': True,
            'category': True, 
            'edits': 0, 
            'pretend': False, 
            'daysago': 0, 
            'sort': None,
            'score': True
        }
	return

    def set(self, what, value):
	self.info[what] = value
	return

    def get(self, what):
	return self.info[what]




def parseargs():
    parser = OptionParser()
    htxt = {
        "--list":         "List the specified category.",
        "--add":          "Add an item to a category. If no destination (category in this case) is specified (using --destination, -D) the default add " + \
                          "category will be used (specified in config file).",
        "--destination":  "Specify to which category an item is to be added/moved/etc., or a new value to be used when using --change, -c.",
        "--delete":       "Delete specified comma separated IDs.",
        "--info":         "Show formated table with information about items with the specified comma separated IDs.",
        "--find":         "Find titles matching specified value.",
        "--move":         "Move title with specified ID to another category. If no destination (category in this case) is specified (using --destination, " + \
                          "-D) the default move category will be used (specified in config file).",
        "--change":       "Change the title of one or more items with the specified comma separated IDs to a new value, specified using --destination, " + \
                          "-D. Here the destination can contain %(#) for self referencing, or %(123) for referencing title with ID 123. See the examples " + \
                          "for more information.",
        "--no-id":        "Hide ID when listing, even if specified in config file to show them.",
        "--no-category":  "Hide category title when listing a category.",
        "--no-color":     "Don't use any color/bold when printing.",
        "--no-newline":   "Don't print newlines. Use ', ' instead of '\\n' (newline) when listing one or more categories.",
        "--no-score":     "Don't print score when listing. Overrides setting in configuration.",
        "--show-score":   "Show score when printing. Overrides setting in configuration.",
        "--add-category": "Add a new category (will edit your config file). Use --destination, -D to specify the category ID.",
        "--force":        "Ignore warnings and continue execution anyway.",
        "--version":      "Show the current version.",
        "--profile":      "Use an alternative profile. A profile name is the name of the config file and the database file. When an alternative profile " + \
                          "is used, their config an db files will be located in ~/.sire/altdb/<name> and ~/.sire/altrc/<name>.",
        "--edits":        "Specify the number of allowed edits to the search value when using --find, -f.",
        "--quiet":        "Be quiet. Don't print notices or warnings. Errors will still be printed.",
        "--verbose":      "Be verbose. Print notices, warnings and errors.",
	"--hide-all":     "Same as -LINC (--no-color --no-id --no-newline --no-category).",
        "--pretend":      "Only pretend to do the speicified things.",
        "--days-ago":     "Only list items added no longer ago than this.",
        "--sort":         "Specify what to sort by. Overrides setting in configuration.",
        "--score":        "Assign a score to an item."
    }
    
    group = OptionGroup(parser, "Hide and/or change output options", "These options will hide or change different types of output.")
    group.add_option("-I", "--no-id", action = "store_true", default = False, dest = "noid", help = htxt["--no-id"])
    group.add_option("-C", "--no-category", action = "store_false", default = True, dest = "printcat", help = htxt["--no-category"])
    group.add_option("-L", "--no-color", action = "store_false", default = True, dest = "printcolor", help = htxt["--no-color"])
    group.add_option("-N", "--no-newline", action = "store_false", default = True, dest = "printnewline", help = htxt["--no-newline"])
    group.add_option("-S", "--no-score", action = "store_true", dest = "noscore", default = None, help = htxt["--no-score"])
    group.add_option("-W", "--show-score", action = "store_false", dest = "noscore", default = None, help = htxt["--show-score"])
    group.add_option("-H", "--hide-all", action = "store_true", default = False, dest = "hide", help = htxt["--hide-all"])
    group.add_option("-q", "--quiet", action = "store_const", const = 0, dest = "verbose", default = 1, help = htxt["--quiet"])
    group.add_option("-v", "--verbose", action = "store_const", const = 2, dest = "verbose", default = 1, help = htxt["--verbose"])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Modify options", "These options will modify items in categories in some way.")
    group.add_option("-a", "--add", dest = "add", help = htxt["--add"], metavar = "TITLE")
    group.add_option("-d", "--delete", dest = "delete", help = htxt["--delete"], metavar = "ID1[,ID2[...]]")
    group.add_option("-m", "--move", type="int", dest = "move", help = htxt["--move"], metavar = "ID")
    group.add_option("-c", "--change", dest = "change", help = htxt["--change"], metavar = "ID1[,ID2[...]]")
    group.add_option("-A", "--add-category", dest = "addcat", help = htxt["--add-category"], metavar = "TITLE")
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Printing options", "These options only prints information and does not modify anything.")
    group.add_option("-f", "--find", dest = "find", help = htxt["--find"], metavar = "VALUE")
    group.add_option("-e", "--edits", type="int", dest = "edits", help = htxt["--edits"], metavar = "VALUE")
    group.add_option("-i", "--info", dest = "info", help = htxt["--info"], metavar = "ID1[,ID2[...]]")
    group.add_option("-l", "--list", dest = "list", help = htxt["--list"], metavar = "CATEGORY")
    group.add_option("-s", "--sort", action = "store", dest = "sort", help = htxt["--sort"])
    group.add_option("-V", "--version", action = "store_true", dest = "version", help = htxt["--version"])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Other options", "Options that does not fit in any other option group and is usually used together with other options.")
    group.add_option("-D", "--destination", dest = "dest", help = htxt["--destination"], metavar = "VALUE")
    group.add_option("-O", "--score", dest = "score", help = htxt["--score"], metavar = "VALUE")
    group.add_option("-P", "--profile", dest = "profile", help = htxt["--profile"], metavar = "NAME")
    group.add_option("-F", "--force", action = "store_true", dest = "force", help = htxt["--force"])
    group.add_option("-p", "--pretend", action = "store_true", dest = "pretend", help = htxt["--pretend"])
    group.add_option("-y", "--days-ago", type = "int", dest = "daysago", help = htxt["--days-ago"], metavar = "DAYS")
    parser.add_option_group(group)
    
    return parser.parse_args()[0]


misc = miscfunctions()


# Prints version number, licence and authors with email.
def version():
    print NAME,VERSION,'\n',LICENCE,'\n\nWritten by: ',AUTHORS,EMAIL
    return



def itemexistsincat(db, config, cat, item):
    if flatfile(config):
	for val in db[cat].values():
	    if val[1] == item:
		return True
	return False

    # SQL
    cursor = dbexec(db, "SELECT * FROM item WHERE title = '" + item + \
	"' AND cat = '" + cat + "'", None, False)
    if len(cursor.fetchall()) > 0:
	return True
    return False


# Internal function to check for already existing items.
def itemexistsid(db, config, id):
    if flatfile(config):
        for key in db.keys():
            for val in db[key].keys():
                if val == id:
                    return True
        return False

    # else we're using sql
    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None, False)
    if len(cursor.fetchall()) > 0:
        return True
    return False

    
# Internal function to check for already existing items.
def get_title_from_id(db, config, id):
    if flatfile(config):
        for key in db.keys():
            for val in db[key].keys():
                if val == id:
                    return True
        return False

    # else we're using sql
    cursor = dbexec(db, "SELECT * FROM item WHERE id = '%s'" % id, None, False)
    res = cursor.fetchall()
    if len(res) > 0:
        return res[0][1]
    error(ERROR["item"] % c(id)) 
    sys.exit(1)




def get_category_from_title(db, config, title):
    if flatfile(config):
        for d in db:
            for b in db[d].values():
                if title in b:
                    return d

        # We didn't find it.
        error(ERROR["notitle"] % c(title))
        sys.exit(1)

    cursor = dbexec(db, "SELECT cat FROM item WHERE title = '%s'" % format_text_in(title), None, False)
    res = cursor.fetchall()
    if len(res) > 0:
        return res[0][0]
    error(ERROR["notitle"] % c(title))
    sys.exit(1)




# Get the category of a title with a certain ID.
def get_category_from_id(db, config, id):
    return get_category_from_title(db, config, get_title_from_id(db, config, id))
    
'''
def get_category_from_id(db, config, id):
    if flatfile(config):
        for d in db:
            if id in db[d].keys():
                return d

        # We didn't find it.
        error(ERROR["nocat"] % c(id))
        sys.exit(1)

    cursor = dbexec(db, "SELECT cat FROM item WHERE id = '%s'" % id, None, False)
    res = cursor.fetchall()
    if len(res) > 0:
        return res[0][0]
    error(ERROR["item"] % c(id))
    sys.exit(1)
''' 






# Internal function to check for already existing items.
def itemexists(db, config, item):
    if flatfile(config):
        for key in db.keys():
            for val in db[key].values():
                if val[2] == item:
                    return True
        return False

    # else we're using sql
    cursor = dbexec(db, "SELECT * FROM item WHERE title = '"+item+"'", None, False)
    if len(cursor.fetchall()) > 0:
        return True
    return False


def get_duplicate_policy(config, cat):
    if not cat is None and ("duplicates." + cat) in config.keys():
	return config["duplicates." + cat]

    elif ("defval.duplicates") in config.keys():
	return config["defval.duplicates"]
    return None



def replace_all(text, dic):
    for i, j in dic.iteritems():
        text = text.replace(i, j)
    
    return text





# Do an approximate string search using the Apse package.
def approxsearch(db, conf, edits, sstr):
    reslist = []
    reps = {'.':' ', '_':' ', '-':' '}

    if edits is 0:
        if "find.edits" in conf.keys():
            edits = int(conf["find.edits"])
        else:
            edits = 0
    
    if edits > 10:
        edits = 10

    elif edits < 0:
        edits = 0

    for str in sstr:
        # allow at most 'edits' edits 
        ap = Apse.Approx(str.lower(), edit=edits)

        for key in db.keys():
            for (id, val) in db[key].items():
                val = val[1]
                val_orig = val.lower()
                fnd = bool(ap.match(val_orig))
                dst = ap.dist(val_orig)
                res = (id, "%s" % val, ("%d", dst), key)

                if fnd and val not in reslist:
                    reslist.append(res)

                # Try to match if we replace some characters.
                val_rep = replace_all(val.lower(), reps)
                fnd_rep = bool(ap.match(val_rep))
                dst_rep = ap.dist(val)
                res_rep = (id, "%s" % val, ("%d", dst_rep), key)

                if not fnd and fnd_rep and val not in reslist:
                    reslist.append(res_rep)

    if reslist != []:
        showcats = False
        if "find.showcats" in conf.keys() and conf["find.showcats"] == '1':
            showcats = True

        note("Match found. Best match at the top.\n")
        old_cat = None

        if showcats:
            reslist.sort(lambda x,y:cmp(x[3],y[3]))
            reslist.reverse()
        
        else:
            reslist.sort(lambda x,y:cmp(x[2],y[2]))
            reslist.reverse()

        for res in reslist:
            if showcats:
                if old_cat is None or res[3] != old_cat:
                    print
		    if misc.get('category'):
                        printcategory(res[3], conf)
                    old_cat = res[3]

            # Make titles aligned.
            spacer = ''
            for i in range(0, 3 - len(res[0])):
                spacer += ' '

            # Showing ID when listing is optional.
            if "general.showid" not in conf.keys() or not misc.get('id'):
                print res[1]
            
            elif conf["general.showid"] == '1':
                print C['bold'] + res[0] + C['default'], spacer + ':', res[1]

    else:
        warning("No matches found!")





def parseconfig(conffile):
    if not os.path.isfile(conffile):
	f = file(conffile, 'w')
	f.close()
	error(ERROR["conf"])
	sys.exit(1)

    _config = {}
    cp = ConfigParser.ConfigParser()
    cp.read(conffile)

    for sec in cp.sections():
        name = string.lower(sec)
        for opt in cp.options(sec):
            _config[name + "." + string.lower(opt)] = string.strip(cp.get(sec, opt))
    return _config





# Print a category (status) description using bold and colors.
def printcategory(category, config):
    if ("categories." + category) not in config.keys():
        error(ERROR["catdesc"] % c(category))
        sys.exit(1)

    if not ("colors." + category) in config.keys():
        if not "colors.defcol" in config.keys():
            color = ''

        else:
            color = C[config["colors.defcol"]]
    else:
        color = C[config["colors." + category]]

    if misc.get('color'):
        print C["bold"], color, config["categories." + category], "('" + category + "')", C["default"]
    else:
        print "  " + config["categories." + category], "('" + category + "')"

    return




# Read the database.
# FIXME: I don't want to load a 500MB file each time I wan't to check what I can watch.
def parsedb(dbfile):
    db = {}
    if not os.path.isfile(dbfile):
	f = file(dbfile, 'w')
	f.close()
	error(ERROR["nodb"])
	sys.exit(1)

    if os.path.getsize(dbfile) == 0:
	warning("Your database is empty.")
	return db

    f = file(dbfile, 'r')
    for line in f.readlines():
        parts = line.split(":", 4)
        parts[4] = parts[4][:-1]

        if not db.has_key(parts[0]):
            db[parts[0]] = {parts[1] : (parts[2], parts[3], parts[4])}
        else:
            db[parts[0]][parts[1]] = (parts[2], parts[3], parts[4])

    f.close()
    return db





# List duplicates, all or in a specific category.
# FIXME: O(n^4) complexity ffs
def listdupes(db, conf, cat):
    dupeids = []

    if flatfile(conf):
        alldbs = db.keys()
    else:
        alldbs = getcatsql(db)

    # If no category is specified, go through every category.
    if cat is None:
        for d in alldbs:
            if flatfile(conf):
                dkeys = db[d].keys()
                dvals = db[d].values()
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+d+"'", None, False)
                result = cursor.fetchall()
                dkeys = [x[0] for x in result]
                dvals = [x[1] for x in result]

            while dvals != []:
                dval = dvals.pop()
                dkey = dkeys.pop()
                if flatfile(conf):
                    dval = dval[1]

                for dd in alldbs:
                    if flatfile(conf):
                        ddkeys = db[dd].keys()
                        ddvals = db[dd].values()
                    else:
                        cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+dd+"'", None, False)
                        result = cursor.fetchall()
                        ddkeys = [x[0] for x in result]
                        ddvals = [x[1] for x in result]
    
                    while ddvals != []:
                        ddval = ddvals.pop()
                        ddkey = ddkeys.pop()
                        if flatfile(conf):
                            ddval = ddval[1]

                        if dkey == ddkey:
                            continue
    
                        if dval == ddval:
                            if dkey not in dupeids:
                                dupeids.append(dkey)
                                print dkey, dval, "(%s)" % d

                            if ddkey not in dupeids:
                                dupeids.append(ddkey)
                                print ddkey, ddval, "(%s)" % dd

    elif not cat in alldbs:
        error(ERROR["nocat"] % c(cat))
        sys.exit(1)

    # Use specified category.
    else:
        if flatfile(conf):
            dkeys = db[cat].keys()
            dvals = db[cat].values()
        else:
            cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+cat+"'", None, False)
            result = cursor.fetchall()
            dkeys = [x[0] for x in result]
            dvals = [x[1] for x in result]

        while dvals != []:
            dval = dvals.pop()
            dkey = dkeys.pop()

            for (k, v) in zip(dkeys, dvals):
                if dval == v:
                    dupeids.append(dval)
                    print dkey, dval, "(%s)" % cat
                    print k, v, "(%s)" % cat
                    print

    if dupeids == []:
        warning("No duplicates found.")




# List either all categories or only the default category.
def list(db, config, category, destination = None):
    pnewline = misc.get('newline')
    pcolor = misc.get('color')
    pscore = misc.get('score')
    pcat = misc.get('category')
    pid = misc.get('id')

    if flatfile(config):
        # Nothing in database.
        if db == {}:
            error(ERROR["emptydb"])
            sys.exit()

        alldbs = db.keys()

    else:
        alldbs = getcatsql(db)

    # Only print the category titles.
    if category == "titles":
        for title in alldbs:
            printcategory(title, config)

        sys.exit()

    output = ''
    newline = ", "
    if pnewline:
        newline = "\n"

    # FIXME sql
    # List duplicates.
    if category == "dupe":
        listdupes(db, config, destination)
        return

    if category == "all":  dbs = alldbs
    elif category == None: dbs = [config["defval.list"]]
    else:                  dbs = [category]

    for category in dbs:
        if category not in alldbs:
            error(ERROR["emptycat"] % c(category))
            sys.exit(1)

        if flatfile(config):
            dbsel = db[category].items()

        else:
            cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+category+"'", None, False)
            dbsel = cursor.fetchall()

        # Sorting is optional.
        if misc.get('sort') is not None:
            sortmethod = misc.get('sort')
        elif ("sort." + category) in config.keys():
            sortmethod = config["sort." + category]
        elif "defval.sort" in config.keys():
            sortmethod = config["defval.sort"]
        else:
            sortmethod = None

        if sortmethod is not None:
            # Sort by specified method.
            if flatfile(config):
                if sortmethod == "title":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[2].lower(),k))
                elif sortmethod == "id":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (int(k),v[2]))
                elif sortmethod == "time":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[0], k))
                elif sortmethod == "score":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[1], k))
                else:
                    dbsel = dbsel

            else:
                if sortmethod == "title":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (v.lower(),int(k),a,b,c))
                elif sortmethod == "id":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (int(k),v,a,b,c))
                elif sortmethod == "time":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (a,int(k),v,b,c))
                elif sortmethod == "score":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b,c): (int(c),int(k),v,a,b))
                else:
                    dbsel = dbsel

        if pcat: 
            printcategory(category, config)

        if flatfile(config):
            for id, value in dbsel:
                title = value[2]
                score = value[1]
                # Make titles aligned.
                sid = sscore = ' '
                for i in range(4 - len(id)):
                    sid += ' '
                for i in range(7 - len(score)):
                    sscore += ' '

                l1 = ['1', None, False]
                l2 = ['0', False]
                gscore = configvalue(config, "general.showscore")

                # Showing ID when listing is optional.
                if configvalue(config, "general.showid") is '1' and pid:
                    output += bold(id, pcolor) + sid + ': '
                if gscore in l1 and pscore in l1 or gscore in l2 and pscore in l2:
                    output += bold(score, pcolor) + sscore + ': '
                output += format_text_out(title) + newline
 
        # SQL
        else:
            for id, title, date, cat, score in dbsel:
                if not limitedtimeago(date):
                    continue

                # Make titles aligned.
                id = str(id)
                sid = sscore = ''
                for i in range(4 - len(id)):
                    sid += ' '
                for i in range(7 - len(str(score))):
                    sscore += ' '

                l1 = ['1', None, False]
                l2 = ['0', False]
                gscore = configvalue(config, "general.showscore")

                # Showing ID when listing is optional.
                if configvalue(config, "general.showid") is '1' and pid:
                    output += bold(id, pcolor) + sid + ': '
                if gscore in l1 and pscore in l1 or gscore in l2 and pscore in l2:
                    output += bold(str(score), pcolor) + sscore + ': '
                output += format_text_out(title) + newline

    output = output.strip()
    if len(output) is 0:
        note("Could not find any items matching your criterion.")
        return

    if output[-1] == ',':
        output = output[:-1]

    print output
    return


def format_text_in(title):
    import re
    title = re.sub('"', "&#34;", title)
    title = re.sub("'", "&#39;", title)
    return title


def format_text_out(title):
    import re
    title = re.sub("&#34;", '"', title)
    title = re.sub("&#39;", "'", title)
    return title


def configvalue(config, ident):
    if ident in config.keys():
        return config[ident]
    return None




def bold(string, color = True):
    if color:
        return C['bold'] + string + C['default']
    return string



def limitedtimeago(date):
    if misc.get('daysago') is not 0:
        tdate = int(time.time())
        if tdate - int(date) > misc.get('daysago')*24*3600:
            return False
    return True


# Add an item to the database.
def add(db, config, name, category, dbfile):
    if ("categories." + category) not in config.keys():
        error(ERROR["nocat"] % c(category))
        sys.exit(1)

    name = format_text_in(name)
    dup = get_duplicate_policy(config, category)

    if dup == "0" and itemexists(db, config, name):
        existing_category = get_category_from_title(db, config, name)
        existing_duplicate = get_duplicate_policy(config, existing_category)
        if existing_duplicate not in ["1", "2"]:
            warning("Item already exists in category '%s'. Use (--force, -f) to add anyway." % c(existing_category))
    	    if not misc.get('force'):
                sys.exit(1)

    if dup == "1" and itemexistsincat(db, config, category, name):
        warning("Item already exists in category '%s'. Use (--force, -f) to add anyway." % c(category))
	if not misc.get('force'):
            sys.exit(1)

    # time.time() returns float, so throw away the ms, then convert to string for writing
    date = str(int(time.time()))

    if flatfile(config):
        l = []
        for k, v in db.iteritems():
            l += v.keys()

        id = '0'
        for i in l:
            if int(i) > int(id):
                id = str(i)

        id = str(int(id) + 1)
	if not category in db.keys():
	    db[category] = {id: (date, 0, name)}
	else:
	    db[category][id] = (date, 0, name)
	savedb(db, config, dbfile)

    else:
        cursor = dbexec(db, "SELECT * FROM curid", None, False)
        id = cursor.fetchall()[0][0] + 1;
        dbexec(db, "UPDATE curid SET id = id + 1", None, True)
        dbexec(db, "INSERT INTO item (id, title, date, cat) VALUES (%s, %s, %s, %s)", (id, name, date, category), True)

    note("Saved '%s' with ID '%s' to category '%s'" % (c(name), c(str(id)), c(category)))
    return


def pretend():
    return misc.get('pretend')



# Execute SQL statement.
def dbexec(db, template, values, volatile):
    # volatile is all UPDATE, INSERT etc.
    if volatile and pretend():
        return

    cursor = db.cursor()
    if values is None:
        cursor.execute(template)
    else:
        cursor.execute(template, values)
    return cursor





# Delete an item from the database.
def delete(db, conf, ids, dbfile):
    if flatfile(conf):
        alldbs = db.keys()
    else:
        alldbs = getcatsql(db)

    ids = str(ids).split(',')

    for id in ids:
        deleted = False
        if flatfile(conf):
            for d in alldbs:
                if db[d].has_key(id):
                    title = db[d][id][1]
                    date = db[d][id][0]
                    del db[d][id]
                    deleted = True
                    break

        # SQL
        else:
            cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None, False)
            result = cursor.fetchall()
            if len(result) == 0:
                error(ERROR["item"] % c(id))
                continue

            d = result[0][3]
            title = result[0][1]
            date = result[0][2]
            dbexec(db, "DELETE FROM item WHERE id = '"+id+"'", None, True)
            deleted = True

        if deleted:
            date = timepassed(date)

            note("Deleted item with ID '%s' and title '%s' from category '%s'." % (c(id), c(format_text_out(title)), c(d)))
            note("It was in that category for %s years, %s days, %s hours, %s minutes and %s seconds." % 
                (date[0], date[1], date[2], date[3], date[4]))

        else:
            error(ERROR["item"] % c(id))

    savedb(db, conf, dbfile)


def getcatsql(db):
    cursor = dbexec(db, "SELECT DISTINCT cat FROM item", None, False)
    return [x[0] for x in cursor.fetchall()]

def timepassed(date):
    date = int(time.time()- int(date))
    return (str(date/60/60/24/365), str(date/60/60/24 % 365), \
        str(date/60/60 % 24), str(date/60 % 60), str(date % 60))

def note(text):
    text = format_text_out(text)
    if misc.get('verbose') is not 0:
	if misc.get('color'):
	    print "%s%sNote: %s%s" % (C["bold"], C["green"], C["default"], text)
	else:
	    print "Note: " + text
    return

def error(text):
    text = format_text_out(text)
    if misc.get('verbose') is not 0:
	if misc.get('color'):
            print "%s%sError: %s%s" % (C["bold"], C["red"], C["default"], text)
	else:
	    print "Error: " + text
    return

def warning(text):
    text = format_text_out(text)
    if misc.get('verbose') is not 0:
	if misc.get('color'):
	    print "%s%sWarning: %s%s" % (C["bold"], C["yellow"], C["default"], text)
	else:
	    print "Warning: " + text
    return


# Save a changed database.
def savedb(db, conf, dbfile):
    if not flatfile(conf) or pretend():
        return
    
    f = open(dbfile, 'w')
    for d in db:
        for id in db[d]:
            tmp = db[d][id]
            f.write("%s:%s:%s:%s:%s\n" % (d, id, tmp[0], tmp[1], tmp[2]))
    f.close()
    return





# Change the value of an item with ID 'id'.
def change(db, conf, id, val_orig, dbfile):
    import re
    # Find all '%([0-9]+)' in 'val'.
    id = id.split(',')
    res = re.findall(r'\%\(([0-9]+|#)\)', format_text_out(val_orig))

    rids = []
    for k, i in enumerate(id):
        if not itemexistsid(db, conf, i):
            warning(ERROR["item"] % i)
            rids = [k] + rids
    for j in rids:
        del id[j]

    if res != []:
        for i in id:
            val = val_orig
            for v in res:
                # This means "if %(#), do this".
                if not cmp(v, '#'):
                    if flatfile(conf):
                        rval = db[get_category_from_id(db, conf, i)][i][1]
                    else:
                        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None, False)
                        result = cursor.fetchall()
                        rval = result[0][1]

                else:
                    if flatfile(conf):
                        rval = db[get_category_from_id(db, conf, v)][v][1]
                    else:
                        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+v+"'", None, False)
                        result = cursor.fetchall()
                        rval = result[0][1]

                p = re.compile('\%\(' + v + '\)')
                val = p.sub(rval, val)

            val = format_text_in(val)
            if flatfile(conf):
                cat = get_category_from_id(db, conf, i)
                old = db[cat][i][1]
                date = db[cat][i][0]
                db[cat][i] = (date, val)
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None, False)
                result = cursor.fetchall()
                old = result[0][1]
                dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None, True)

            note("Changed item with ID '%s' from '%s' to '%s'." % (c(i), c(format_text_out(old)), c(format_text_out(val))))

    else:
        for i in id:
            val = format_text_in(val_orig)
            if flatfile(conf):
                cat = get_category_from_id(db, config, i)
                old = db[cat][i][1]
                date = db[cat][i][0]
                db[cat][i] = (date, val)
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None, False)
                result = cursor.fetchall()
                old = result[0][1]
                dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None, True)

            note("Changed item with ID '%s' from '%s' to '%s'." % (c(i), c(format_text_out(old)), c(format_text_out(val))))

    savedb(db, conf, dbfile)




# Move an item with ID 'id' to a new category.
def move(db, conf, id, newcat, dbfile):
    if not ("categories." + newcat) in conf.keys():
        error(ERROR["nocat"] % c(newcat))
        sys.exit(1)

    newdate = str(int(time.time()))

    if flatfile(conf):
        found = False
        for d in db:
            if id in db[d].keys():
                found = True
                break;

        if not found:
            error(ERROR["item"] % c(id))
            sys.exit(1)

        date = timepassed(db[d][id][0])
        newdate = str(int(time.time()))
        title = db[d][id][1]

        if db.has_key(newcat):
            db[newcat][id] = (newdate, title)
        else:
            db[newcat] = dict([(id, (newdate, title))])

        del db[d][id]

    # SQL
    else:
        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None, False)
        result = cursor.fetchall()
        if len(result) == 0:
            error(ERROR["item"] % c(id))
            sys.exit(1)

        dbexec(db, "UPDATE item SET cat = '"+newcat+"' WHERE id = '"+id+"'", None, True)
        dbexec(db, "UPDATE item SET date = '"+newdate+"' WHERE id = '"+id+"'", None, True)
        date = timepassed(result[0][2])
        title = result[0][1]
        d = result[0][3]

    note("Moved item with ID '%s' and title '%s' from category '%s' to '%s'." % (c(id), c(format_text_out(title)), c(d), c(newcat)))
    note("It was in that category for %s years, %s days, %s hours, %s minutes and %s seconds." % 
        (date[0], date[1], date[2], date[3], date[4]))

    savedb(db, conf, dbfile)


def c(text):
    if misc.get('color'):
	return C['g'] + text + C['d']
    return text








# Detirmine if we're using flatfile or mysql as database.
def flatfile(config):
    if ("database.type" not in config.keys()):
        return True

    if config["database.type"] == "mysql":
        return False

    return True





# Prints formated table with info about items with specified IDs.
def info(db, conf, ids):
    sl_id = 1
    sl_title = 1
    sl_date = 1
    sl_date_added = 1
    sl_category = 1
    items = []
    ids = ids.split(',')

    if flatfile(conf):
        alldbs = db
    else:
        alldbs = getcatsql(db)

    for id in ids:
        found = False
        for d in alldbs:
            if flatfile(conf):
                catids = db[d].keys()
            else:
                cursor = dbexec(db, "SELECT DISTINCT id FROM item WHERE cat = '"+d+"'", None, False)
                catids = [int(x[0]) for x in cursor.fetchall()]

            if int(id) in catids:
                found = True

                if flatfile(conf):
                    title = db[d][id][1]
                    date = db[d][id][0]
                else:
                    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None, False)
                    result = cursor.fetchall()
                    title = result[0][1]
                    date = result[0][2]

                da = time.gmtime(int(date))
                date_added = str(da[0]) + "-" + str(da[1]) + "-" + str(da[2]) + ", " + \
                    str(da[3]) + ":" + str(da[4]) + ":" + str(da[5])
                date_in_cat = timepassed(date)
                cat = conf["categories." + d]

                items.append((id, format_text_out(title), cat, date_added, date_in_cat))

                if len(id) > sl_id:
                    sl_id = len(id)

                if len(title) > sl_title:
                    sl_title = len(title)

                if len(date_added) > sl_date_added:
                    sl_date_added = len(date_added)

                if len(cat) > sl_category:
                    sl_category = len(cat)

                break;
        
        if not found:
            error(ERROR["item"] % c(id))

    print

    sys.stdout.write("ID")
    for i in (range(sl_id + 1)):
        sys.stdout.write(" ")
    sys.stdout.write("TITLE")
    for i in (range(sl_title - 2)):
        sys.stdout.write(" ")
    sys.stdout.write("CATEGORY")
    for i in (range(sl_category - 5)):
        sys.stdout.write(" ")
    sys.stdout.write("DATE ADDED")
    for i in (range(sl_date_added - 7)):
        sys.stdout.write(" ")
    sys.stdout.write("TIME IN CATAGORY")

    print
    print
    for item in items:
        sys.stdout.write(item[0])
        for i in (range(sl_id         - len(item[0]) + 3)):
                sys.stdout.write(" ")

        sys.stdout.write(item[1])
        for i in (range(sl_title      - len(item[1]) + 3)):
                sys.stdout.write(" ")

        sys.stdout.write(item[2])
        for i in (range(sl_category   - len(item[2]) + 3)):
            sys.stdout.write(" ")

        sys.stdout.write(item[3])
        for i in (range(sl_date_added - len(item[3]) + 3)):
            sys.stdout.write(" ")

        print item[4][0]+"y", item[4][1]+"d", item[4][2]+"h", item[4][3]+"m", item[4][4]+"s"
        




def sortdict(adict):
    items = adict.items()
    items.sort()
    return [(key, value) for key, value in items]





def saveconfig(config, configfile):
    if pretend():
        return

    cf = open(configfile, 'wb')
    for sec in config.sections():
        name = string.lower(sec)
	cf.write("\n[" + name + "]\n")
        for opt in config.options(sec):
            cf.write(string.lower(opt) + ": " + string.strip(config.get(sec, opt)) + "\n")

    cf.close()

    return





def newcategory(configfile, title, id):
    sections = ["categories", "defval", "general"]

    config = ConfigParser.ConfigParser()
    config.read(configfile)

    if config.has_option("categories", id):
        error("Category with ID '%s' already exists with the title '%s'." % (c(id), c(title)))
        sys.exit(1)

    for section in sections:
	if not config.has_section(section):
	    config.add_section(section)

    config.set("categories", id, title)
    confs = [
        ("defval", "move-" + id, id), 
        ("defval", "list", id), 
        ("defval", "add", id),
        ("defval", "sort", "title"),
        ("defval", "color", "green"),
        ("defval", "duplicates", 0),
        ("general", "showid", 1)
    ]

    for conf in confs:
        if not config.has_option(conf[0], conf[1]):
            config.set(conf[0], conf[1], conf[2])

    saveconfig(config, configfile)

    note("Added category '%s' with title '%s'." % (c(id), c(title)))

    return





def setscore(db, dbfile, config, id, score):
    if flatfile(config):
        tmp = db[get_category_from_id(db, config, id)][id]
        db[get_category_from_id(db, config, id)][id] = (tmp[0], score, tmp[2])
        savedb(db, config, dbfile)
    else:
        dbexec(db, "UPDATE item SET score = '"+score+"' WHERE id = '"+id+"'", None, True)

    title = get_title_from_id(db, config, id)
    note("Assigned score '%s' to item with ID '%s' and value '%s'." % (c(score), c(id), c(format_text_out(title))))

    return





def changedb(config, dbfile):
    config["database.type"] = "flatfile"
    db = parsedb(dbfile)

    return db





# Handle command line arguments.
def main():
    # Check if config and database files exists and are read- and writeable.
    if not os.path.exists(DB) or not os.path.exists(CONFIG):
        error(ERROR["dbcat"])
        sys.exit(1)

    # Read the config file.
    config = parseconfig(CONFIG)

    if flatfile(config):
        # Always backup the database before ding anything. Will overwrite older backup.
        shutil.copy(DB, PATH + "/.siredb.backup")
        # First read the database from the file.
        db = parsedb(DB)

    else:
        db = MySQLdb.connect(
            config["database.host"], 
            config["database.user"], 
            config["database.pass"], 
            config["database.name"])

    configfile = CONFIG
    dbfile = DB

    opts = parseargs()

    if opts.pretend is True:
        misc.set('pretend', True)

    if opts.version is True:
        version()
        return

    if opts.profile is not None:
	profile = opts.profile
        config = parseconfig(ALTRC + profile)
        configfile = ALTRC + profile
        dbfile = ALTDB + profile
        db = changedb(config, dbfile)

    if opts.daysago is not None:
        misc.set('daysago', opts.daysago)

    if opts.noid is True:
	misc.set('id', False)

    if opts.printcolor is False:
	misc.set('color', False)

    if opts.printnewline is False:
	misc.set('newline', False)

    if opts.printcat is False:
	misc.set('category', False)

    if opts.hide is True:
	misc.set('id', False)
	misc.set('color', False)
	misc.set('newline', False)
	misc.set('category', False)

    if opts.verbose is not None:
	misc.set('verbose', opts.verbose)

    if opts.force is True:
	misc.set('force', True)

    if opts.sort is not None:
        misc.set('sort', opts.sort)
        
    # Will always either be True, False or None, even if not specified.
    misc.set('score', opts.noscore)

    if opts.edits is not None:
	misc.set('edits', opts.edits)

    # Options that do things comes last.
    if opts.addcat is not None:
	if opts.dest is None:
	    error(ERROR["destcat"])
	    sys.exit(1)
	newcategory(configfile, opts.addcat, opts.dest)
	return

    if opts.find is not None:
	approxsearch(db, config, misc.get('edits'), opts.find)
	return

    if opts.move is not None:
	id = str(opts.move)
	if opts.dest is not None:
	    newcat = opts.dest
	    move(db, config, id, newcat, dbfile)
	    return

	# User didn't specify what category to move to, try to use the default value.
        curcat = get_category_from_id(db, config, id)

        # Try default for current category.
        newcat = "defval.move-" + curcat
        if not newcat in config.keys():
            # Otherwise try to use default for all categories.
            if not "defval.move" in config.keys():
                error(ERROR["destdefcat"])
                sys.exit(1)
            else: newcat = config["defval.move"]
        else: newcat = config[newcat]
        move(db, config, id, newcat, dbfile)
        return

    if opts.change is not None:
	if opts.dest is None:
	    error(ERROR["destchg"])
	    sys.exit(1)

        change(db, config, opts.change, opts.dest, dbfile)
	return

    if opts.delete is not None:
        delete(db, config, opts.delete, dbfile)
	return

    if opts.info is not None:
        info(db, config, opts.info)
	return

    if opts.add is not None:
	title = opts.add

	if opts.dest is not None:
	    category = opts.dest
	else:
	    if not "defval.add" in config.keys():
		error(ERROR["defadd"])
		sys.exit(1)
	    category = config["defval.add"]

        add(db, config, title, category, dbfile)
	return

    if opts.score is not None:
        if opts.dest is None:
            error(ERROR["destscore"])
            sys.exit(1)

        if not itemexistsid(db, config, opts.dest):
            error(ERROR["item"] % c(opts.dest))
            sys.exit(1)

        setscore(db, dbfile, config, opts.dest, opts.score)
        return
        
	
    # Nothing else was done, so list a category.
    category = None
    if opts.list is not None:
	category = opts.list
    list(db, config, category, opts.dest)
    
    return




# Call main().
if __name__ == "__main__":
    main()
    sys.exit()
