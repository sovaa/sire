#!/usr/bin/python

import string, sys, getopt, os, re, ConfigParser, time, shutil
import Apse # for approximate searching
import MySQLdb # database
from optparse import OptionParser
from optparse import OptionGroup

HOME = os.path.expanduser("~")
PATH = HOME + "/.sire/"
CONFIG = PATH + "/sirerc"
DB = PATH + "/siredb"
ALTDB = PATH + "/altdb/"
ALTRC = PATH + "/altrc/"

NAME = "sire"
VERSION = "0.1.7"
AUTHORS = "Oscar Eriksson"
EMAIL = "(oscar.eriks@gmail.com)"
LICENCE = '''License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to move and redistribute it.
There is NO WARRANTY, to the extent permitted by law.'''

C = { 
    'default' : "\033[0m",
    'd'       : "\033[0m",
    'bold'    : "\033[1m",
    'b'       : "\033[1m",
    'red'     : "\033[31m",
    'green'   : "\033[32m",
    'g'       : "\033[32m",
    'yellow'  : "\033[33m",
    'blue'    : "\033[34m",
    'magenta' : "\033[35m",
    'm'       : "\033[35m",
    'cyan'    : "\033[36m",
}

# Define arguemnts.
#opts, args = getopt.gnu_getopt(
#    sys.argv[1:], # Arguements from commandline.
#    'Fqku:y:gp:we:nl:hotcvfiad:m',  # Short arguments.
#    ['force', 'quiet', 'temp-add', 'category-title=', 'category-id=', 'add-category', 'profile=', 'no-newline', 'no-category', 'no-color', 'edits=', 'no-id', 'list=', 'change', 'info', 'add', 'move', 'delete=', 'find', 'help', 'version'] # Long arguments.
#)

class miscfunctions:
    def __init__(self):
	self.map = {'force': 0, 'verbose': 1, 'color': 2, 'id': 3, 'newline': 4, 'category': 5, 'edits': 6}
	self.info = [False, 1, True, True, True, True, 0]
	return

    def set(self, what, value):
	self.info[self.map[what]] = value
	return

    def get(self, what):
	return self.info[self.map[what]]



def parseargs():
    parser = OptionParser()
    helptext = [
        "List the specified category.",
        "Add an item to a category. If no destination (category in this case) is specified (using --destination, -D) the default add category will be used (specified in config file).",
        "Specify to which category an item is to be added/moved/etc., or a new value to be used when using --change, -c.",
        "Delete specified comma separated IDs.",
        "Show formated table with information about items with the specified comma separated IDs.",
        "Find titles matching specified value.",
        "Move title with specified ID to another category. If no destination (category in this case) is specified (using --destination, -D) the default move category will be used (specified in config file).",
        "Change the title of one or more items with the specified comma separated IDs to a new value, specified using --destination, -D. Here the destination can contain %(#) for self referencing, or %(123) for referencing title with ID 123. See the examples for more information.",
        "Hide ID when listing, even if specified in config file to show them.",
        "Hide category title when listing a category.",
        "Don't use any color/bold when printing.",
        "Don't print newlines. Use ', ' instead of '\\n' (newline) when listing one or more categories.",
        "Add a new category (will edit your config file). Use --destination, -D to specify the category ID.",
        "Ignore warnings and continue execution anyway.",
        "Show the current version.",
        "Use an alternative profile. A profile name is the name of the config file and the database file. When an alternative profile is used, their config an db files will be located in ~/.sire/altdb/<name> and ~/.sire/altrc/<name>.",
        "Specify the number of allowed edits to the search value when using --find, -f.",
        "Be quiet. Don't print notices or warnings. Errors will still be printed.",
        "Be verbose. Print notices, warnings and errors.",
	"Same as -LINC (--no-color --no-id --no-newline --no-category)."
    ]
    
    group = OptionGroup(parser, "Hide and/or change output options", "These options will hide or change different types of output.")
    group.add_option("-I", "--no-id", action = "store_false", default = True, dest = "printid", help = helptext[8], metavar = "")
    group.add_option("-C", "--no-category", action = "store_false", default = True, dest = "printcat", help = helptext[9], metavar = "")
    group.add_option("-L", "--no-color", action = "store_false", default = True, dest = "printcolor", help = helptext[10], metavar = "")
    group.add_option("-N", "--no-newline", action = "store_false", default = True, dest = "printnewline", help = helptext[11], metavar = "")
    group.add_option("-H", "--hide-all", action = "store_true", default = False, dest = "hide", help = helptext[19], metavar = "")
    group.add_option("-q", "--quiet", action = "store_const", const = 0, dest = "verbose", default = 1, help = helptext[17])
    group.add_option("-V", "--verbose", action = "store_const", const = 2, dest = "verbose", default = 1, help = helptext[18])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Modify options", "These options will modify items in categories in some way.")
    group.add_option("-a", "--add", dest = "add", help = helptext[1], metavar = "TITLE")
    group.add_option("-d", "--delete", dest = "delete", help = helptext[3], metavar = "ID1[,ID2[...]]")
    group.add_option("-m", "--move", type="int", dest = "move", help = helptext[6], metavar = "ID")
    group.add_option("-c", "--change", dest = "change", help = helptext[7], metavar = "ID1[,ID2[...]]")
    group.add_option("-A", "--add-category", dest = "addcat", help = helptext[12], metavar = "TITLE")
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Printing options", "These options only prints information and does not modify anything.")
    group.add_option("-f", "--find", dest = "find", help = helptext[5], metavar = "VALUE")
    group.add_option("-e", "--edits", type="int", dest = "edits", help = helptext[16], metavar = "VALUE")
    group.add_option("-i", "--info", dest = "info", help = helptext[4], metavar = "ID1[,ID2[...]]")
    group.add_option("-l", "--list", dest = "list", help = helptext[0], metavar = "CATEGORY")
    group.add_option("-v", "--version", action = "store_true", dest = "version", help = helptext[14])
    parser.add_option_group(group)
    
    group = OptionGroup(parser, "Other options", "Options that does not fit in any other option group and is usually used together with other options.")
    group.add_option("-D", "--destination", dest = "dest", help = helptext[2], metavar = "VALUE")
    group.add_option("-p", "--profile", dest = "profile", help = helptext[15], metavar = "NAME")
    group.add_option("-F", "--force", action = "store_true", dest = "force", help = helptext[13], metavar = "")
    parser.add_option_group(group)
    
    return parser.parse_args()[0]


misc = miscfunctions()


# Prints version number, licence and authors with email.
def version():
    print NAME,VERSION,'\n',LICENCE,'\n\nWritten by: ',AUTHORS,EMAIL
    return



def itemexistsincat(db, config, cat, item):
    if flatfile(config):
	for val in db[cat].values():
	    if val[1] == item:
		return True
	return False

    # SQL
    cursor = dbexec(db, "select * from item where title = '" + title + \
	"' and category = '" + cat + "'", None)
    if len(cursor.fetchall()) > 0:
	return True
    return False



# Internal function to check for already existing items.
def itemexists(db, config, item):
    if flatfile(config):
        for key in db.keys():
            for val in db[key].values():
                if val[1] == item:
                    return True
        return False

    # else we're using sql
    cursor = dbexec(db, "select * from item where title = '"+item+"'", None)
    if len(cursor.fetchall()) > 0:
        return True
    return False


def getdup(config, cat):
    if not cat is None and ("duplicates." + cat) in config.keys():
	return config["duplicates." + cat]

    elif ("defval.duplicates") in config.keys():
	return config["defval.duplicates"]
    return None



def replace_all(text, dic):
    for i, j in dic.iteritems():
        text = text.replace(i, j)
    
    return text





# Do an approximate string search using the Apse package.
def approxsearch(db, conf, edits, sstr):
    reslist = []
    reps = {'.':' ', '_':' ', '-':' '}

    if edits is 0:
        if "find.edits" in conf.keys():
            edits = int(conf["find.edits"])
        else:
            edits = 0
    
    if edits > 10:
        edits = 10

    elif edits < 0:
        edits = 0

    for str in sstr:
        # allow at most 'edits' edits 
        ap = Apse.Approx(str.lower(), edit=edits)

        for key in db.keys():
            for (id, val) in db[key].items():
                val = val[1]
                val_orig = val.lower()
                fnd = bool(ap.match(val_orig))
                dst = ap.dist(val_orig)
                res = (id, "%s" % val, ("%d", dst), key)

                if fnd and val not in reslist:
                    reslist.append(res)

                # Try to match if we replace some characters.
                val_rep = replace_all(val.lower(), reps)
                fnd_rep = bool(ap.match(val_rep))
                dst_rep = ap.dist(val)
                res_rep = (id, "%s" % val, ("%d", dst_rep), key)

                if not fnd and fnd_rep and val not in reslist:
                    reslist.append(res_rep)

    if reslist != []:
        showcats = False
        if "find.showcats" in conf.keys() and conf["find.showcats"] == '1':
            showcats = True

        print "Match found. Best match at the top.\n"
        old_cat = None

        if showcats:
            reslist.sort(lambda x,y:cmp(x[3],y[3]))
            reslist.reverse()
        
        else:
            reslist.sort(lambda x,y:cmp(x[2],y[2]))
            reslist.reverse()

        for res in reslist:
            if showcats:
                if old_cat is None or res[3] != old_cat:
                    print
		    if misc.get('category'):
                        printcategory(res[3], conf)
                    old_cat = res[3]

            # Make titles aligned.
            spacer = ''
            for i in range(0, 3 - len(res[0])):
                spacer += ' '

            # Showing ID when listing is optional.
            if "general.showid" not in conf.keys() or not misc.get('id'):
                print res[1]
            
            elif conf["general.showid"] == '1':
                print C['bold'] + res[0] + C['default'], spacer + ':', res[1]

    else:
        print "No matches found!"





def parseconfig(conffile):
    if not os.path.isfile(conffile):
	f = file(conffile, 'w')
	f.close()
	error("Config file didn't exist. I created it for you. Populate it before continuing.")
	sys.exit(1)

    _config = {}
    cp = ConfigParser.ConfigParser()
    cp.read(conffile)
    for sec in cp.sections():
        name = string.lower(sec)
        for opt in cp.options(sec):
            _config[name + "." + string.lower(opt)] = string.strip(cp.get(sec, opt))
    return _config





# Print a category (status) description using bold and colors.
def printcategory(category, config):
    if ("categories." + category) not in config.keys():
        error("There is no Catagory description for category '"+c(category)+"'!")
        sys.exit(1)

    if not ("colors." + category) in config.keys():
        if not "colors.defcol" in config.keys():
            color = ''

        else:
            color = C[config["colors.defcol"]]
    else:
        color = C[config["colors." + category]]

    if misc.get('color'):
        print C["bold"], color, config["categories." + category], "('" + category + "')", C["default"]
    else:
        print "  " + config["categories." + category], "('" + category + "')"

    return




# Read the database.
# FIXME: I don't want to load a 500MB file each time I wan't to check what I can watch.
def parsedb(dbfile):
    db = {}
    if not os.path.isfile(dbfile):
	f = file(dbfile, 'w')
	f.close()
	error("Database didn't exist. I created it for you.")
	sys.exit(1)

    if os.path.getsize(dbfile) == 0:
	warning("Your database is empty.")
	return db

    f = file(dbfile, 'r')
    for line in f.readlines():
        parts = line.split(":", 3)
        parts[3] = parts[3][:-1]

        if not db.has_key(parts[0]):
            db[parts[0]] = {parts[1] : (parts[2], parts[3])}

        else:
            db[parts[0]][parts[1]] = (parts[2], parts[3])

    f.close()
    return db





# List duplicates, all or in a specific category.
# FIXME: O(n^4) complexity ffs
def listdupes(db, conf, cat):
    dupeids = []

    if flatfile(conf):
        alldbs = db.keys()
    else:
        alldbs = getcatsql(db)

    # If no category is specified, go through every category.
    if cat is None:
        for d in alldbs:
            if flatfile(conf):
                dkeys = db[d].keys()
                dvals = db[d].values()
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+d+"'", None)
                result = cursor.fetchall()
                dkeys = [x[0] for x in result]
                dvals = [x[1] for x in result]

            while dvals != []:
                dval = dvals.pop()
                dkey = dkeys.pop()
                if flatfile(conf):
                    dval = dval[1]

                for dd in alldbs:
                    if flatfile(conf):
                        ddkeys = db[dd].keys()
                        ddvals = db[dd].values()
                    else:
                        cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+dd+"'", None)
                        result = cursor.fetchall()
                        ddkeys = [x[0] for x in result]
                        ddvals = [x[1] for x in result]
    
                    while ddvals != []:
                        ddval = ddvals.pop()
                        ddkey = ddkeys.pop()
                        if flatfile(conf):
                            ddval = ddval[1]

                        if dkey is ddkey:
                            continue
    
                        if dval == ddval:
                            if dkey not in dupeids:
                                dupeids.append(dkey)
                                print dkey, dval, "(%s)" % d

                            if ddkey not in dupeids:
                                dupeids.append(ddkey)
                                print ddkey, ddval, "(%s)" % dd

    elif not cat in alldbs:
        print "Catagory does not exist."
        sys.exit(1)

    # Use specified category.
    else:
        if flatfile(conf):
            dkeys = db[cat].keys()
            dvals = db[cat].values()
        else:
            cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+cat+"'", None)
            dkeys = [x[0] for x in cursor.fetchall()]
            dvals = [x[1] for x in cursor.fetchall()]

        while dvals != []:
            dval = dvals.pop()
            dkey = dkeys.pop()
            dval = dval[1]

            for (k, v) in zip(dkeys, dvals):
                if dval == v[1]:
                    dupeids.append(dval)
                    print dkey, dval, "(%s)" % cat
                    print k, v[1], "(%s)" % cat
                    print

    if dupeids == []:
        print "No duplicates found."




# List either all categories or only the default category.
def list(db, config, category):
    pnewline = misc.get('newline')
    pcolor = misc.get('color')
    pcat = misc.get('category')
    pid = misc.get('id')

    if flatfile(config):
        # Nothing in database.
        if db == {}:
            error("Your database is empty.")
            sys.exit()

        alldbs = db.keys()

    else:
        alldbs = getcatsql(db)

    # FIXME sql
    # Only print the category titles.
    if category == "titles":
        for title in alldbs:
            printcategory(title, config)

        sys.exit()

    newline = ", "
    if pnewline:
        newline = "\n"

    # FIXME sql
    # List duplicates.
    if category == "dupe":
        if len(sys.argv) < 4:
            listdupes(db, config, None)

        else:
            listdupes(db, config, sys.argv[3])

        sys.exit()

    if category == "all":  dbs = alldbs
    elif category == None: dbs = config["defval.list"]
    else:                  dbs = [category]

    for category in dbs:
        if category not in alldbs:
            error("Empty category '"+c(category)+"'.")
            sys.exit(1)

        if flatfile(config):
            dbsel = db[category].items()

        else:
            cursor = dbexec(db, "SELECT * FROM item WHERE cat = '"+category+"'", None)
            dbsel = cursor.fetchall()

        # Sorting is optional.
        if ("sort." + category) in config.keys():
            sortmethod = config["sort." + category]

        elif "defval.sort" in config.keys():
            sortmethod = config["defval.sort"]

        else:
            sortmethod = False

        if sortmethod is not False:
            # Sort by specified method.
            if flatfile(config):
                if sortmethod == "title":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[1].lower(),k))
                elif sortmethod == "id":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (int(k),v[1]))
                elif sortmethod == "time":
                    dbsel = sorted(db[category].items(), key=lambda (k,v): (v[0], k))
                else:
                    dbsel = dbsel

            else:
                if sortmethod == "title":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b): (v.lower(),k,a,b))
                elif sortmethod == "id":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b): (int(k),v,a,b))
                elif sortmethod == "time":
                    dbsel = sorted(dbsel, key=lambda (k,v,a,b): (a,k,v,b))
                else:
                    dbsel = dbsel

        if pcat: 
            printcategory(category, config)

        if flatfile(config):
	    output = ''
            for id, title in dbsel:
                # Make titles aligned.
                title = title[1]
                spacer = ''
                for i in range(0, 3 - len(id)):
                    spacer += ' '

                # Showing ID when listing is optional.
                if "general.showid" not in config.keys() or not pid:
                    output += title + newline

                elif config["general.showid"] == '1':
                    if pcolor:
                        output += C['bold'] + id + C['default'] + spacer + ' : ' + title + newline

                    else:
                        output += id + spacer + ' : ' + title + newline

                else:
                    output += title + newline
 
        # SQL
        else:
            output = ''
            for id, title, date, cat in dbsel:
                # Make titles aligned.
                id = str(id)
                spacer = ''
                for i in range(0, 3 - len(id)):
                    spacer += ' '

                # Showing ID when listing is optional.
                if "general.showid" not in config.keys() or not pid:
                    output += title + newline
            
                elif config["general.showid"] == '1':
                    if pcolor:
                        output += C['bold'] + id + C['default'] + ' ' + spacer + ': ' + title + newline
                    else:
                        output += id + ' ' + spacer + ': ' + title + newline

                else:
                    output += title + newline
 
    output = output.strip()
    if output[-1] == ',':
            output = output[:-1]

    print output
    return


# Add an item to the database.
def add(db, config, name, category, dbfile):
    if ("categories." + category) not in config.keys():
        error("Specified category does not exist.")
        sys.exit(1)

    dup = getdup(config, category)

    if dup == "0" and itemexists(db, config, name):
        error("Item already exists in category '" + c(category) + "'.")
	if not misc.get('force'):
            sys.exit(1)

    if dup == "1" and itemexistsincat(db, config, category, name):
        error("Item already exists in category '" + c(category) + "'.")
	if not misc.get('force'):
            sys.exit(1)

    # time.time() returns float, so throw away the ms, then convert to string for writing
    date = str(int(time.time()))

    if flatfile(config):
        l = []
        for k, v in db.iteritems():
            l += v.keys()

        id = "0"
        for i in l:
            if int(i) > int(id):
                id = str(i)

        id = str(int(id) + 1)
	if not category in db.keys():
	    db[category] = {id: (date, name)}
	else:
	    db[category][id] = (date, name)
	savedb(db, config, dbfile)

    else:
        cursor = dbexec(db, "SELECT * FROM curid", None)
        id = cursor.fetchall()[0][0] + 1;
        dbexec(db, "UPDATE curid SET id = id + 1", None)
        dbexec(db, "INSERT INTO item (id, title, date, cat) VALUES (%s, %s, %s, %s)", (id, name, date, category))

    # FIXME: huh? why is this here? already checked
    #if itemexists(db, config, name):
    #    warning("Item already exists in category '" + c(category) + "'.")

    note("Saved '" + c(name) + "' with id '" + c(str(id)) + "'.")
    return




# Execute SQL statement.
def dbexec(db, template, values):
    cursor = db.cursor()
    if values is None:
        cursor.execute(template)
    else:
        cursor.execute(template, values)
    return cursor





# Delete an item from the database.
def delete(db, conf, ids, dbfile):
    if flatfile(conf):
        alldbs = db.keys()
    else:
        alldbs = getcatsql(db)

    ids = ids.split(',')

    for id in ids:
        deleted = False
        for d in alldbs:
            if flatfile(conf):
                if db[d].has_key(id):
                    title = db[d][id][1]
                    date = db[d][id][0]
                    del db[d][id]
                    deleted = True
                    break

            # SQL
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
                result = cursor.fetchall()
                if len(result) == 0:
                    continue

                title = result[0][1]
                date = result[0][2]
                dbexec(db, "DELETE FROM item WHERE id = '"+id+"'", None)
                deleted = True
                break

        if deleted:
            date = timepassed(date)

            note("Deleted item with ID '"+c(id)+"' and title '"+c(title)+"' from category '"+c(d)+"'.")
            note("It was in that category for "+date[0]+" years, "+date[1]+ \
                " days, "+date[2]+" hours, "+date[3]+" minutes and "+date[4]+" seconds.")

        else:
            error("Item with ID '"+c(id)+"' not found.")

    savedb(db, conf, dbfile)


def getcatsql(db):
    cursor = dbexec(db, "SELECT DISTINCT cat FROM item", None)
    return [x[0] for x in cursor.fetchall()]

def timepassed(date):
    date = int(time.time()- int(date))
    return (str(date/60/60/24/365), str(date/60/60/24 % 365), \
        str(date/60/60 % 24), str(date/60 % 60), str(date % 60))

def note(text):
    if misc.get('verbose') is 2:
	if misc.get('color'):
	    print C["bold"] + C["green"] + "Note: " + C["default"] + text
	else:
	    print "Note: " + text
    return

def error(text):
    if misc.get('verbose') is not 0:
	if misc.get('color'):
            print C["bold"] + C["red"] + "Error: " + C["default"] + text
	else:
	    print "Error: " + text
    return

def warning(text):
    if misc.get('verbose') is not 0:
	if misc.get('color'):
	    print C["bold"] + C["yellow"] + "Warning: " + C["default"] + text
	else:
	    print "Warning: " + text
    return


# Save a changed database.
def savedb(db, conf, dbfile):
    if not flatfile(conf):
        return
    
    f = open(dbfile, 'w')
    for d in db:
        for id in db[d]:
            f.write(d + ":" + id + ":" + db[d][id][0] + ":" + db[d][id][1] + "\n")

    f.close()





# Change the value of an item with ID 'id'.
def change(db, conf, id, val_orig, dbfile):
    # Find all '%([0-9+)' in 'val'.
    id = id.split(',')
    res = re.findall(r'\%\(([0-9]+|#)\)', val_orig)

    if res != []:
        for i in id:
            val = val_orig
            for v in res:
                # This means "if %(#), do this".
                if not cmp(v, '#'):
                    if flatfile(conf):
                        rval = db[getcat(db, i)][i][1]
                    else:
                        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None)
                        result = cursor.fetchall()
                        rval = result[0][1]

                else:
                    if flatfile(conf):
                        rval = db[getcat(db, v)][v][1]
                    else:
                        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+v+"'", None)
                        result = cursor.fetchall()
                        rval = result[0][1]

                p = re.compile('\%\(' + v + '\)')
                val = p.sub(rval, val)

            if flatfile(conf):
                cat = getcat(db, i)
                old = db[cat][i][1]
                date = db[cat][i][0]
                db[cat][i] = (date, val)
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None)
                result = cursor.fetchall()
                old = result[0][1]
                dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None)

            print "Changed item '"+c(i)+"' from '"+c(old)+"' to '" + c(val)+"'."

    else:
        for i in id:
            val = val_orig
            if flatfile(conf):
                cat = getcat(db, i)
                old = db[cat][i][1]
                date = db[cat][i][0]
                db[cat][i] = (date, val)
            else:
                cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+i+"'", None)
                result = cursor.fetchall()
                old = result[0][1]
                dbexec(db, "UPDATE item SET title = '"+val+"' WHERE id = '"+i+"'", None)

            print "Changed item '"+c(i)+"' from '"+c(old)+"' to '" + c(val)+"'."

    savedb(db, conf, dbfile)




# Move an item with ID 'id' to a new category.
def move(db, conf, id, newcat, dbfile):
    if not ("categories." + newcat) in conf.keys():
        error("No such category '" + c(newcat) + "'. Add it in the sirerc first.")
        sys.exit(1)

    newdate = str(int(time.time()))

    if flatfile(conf):
        found = False
        for d in db:
            if id in db[d].keys():
                found = True
                break;

        if not found:
            error("No item with ID '"+c(id)+"'.")
            sys.exit(1)

        date = timepassed(db[d][id][0])
        newdate = str(int(time.time()))
        title = db[d][id][1]

        if db.has_key(newcat):
            db[newcat][id] = (newdate, title)
        else:
            db[newcat] = dict([(id, (newdate, title))])

        del db[d][id]

    # SQL
    else:
        cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
        result = cursor.fetchall()
        if len(result) == 0:
            error("No item with ID '"+c(id)+"'.")
            sys.exit(1)

        dbexec(db, "UPDATE item SET cat = '"+newcat+"' WHERE id = '"+id+"'", None)
        dbexec(db, "UPDATE item SET date = '"+newdate+"' WHERE id = '"+id+"'", None)
        date = timepassed(result[0][2])
        title = result[0][1]
        d = result[0][3]

    print "Moved item with ID '"+c(id)+"' and title '"+c(title)+"' from category '"+c(d)+"' to '"+c(newcat)+"'."
    print "It was in that category for "+date[0], "years,", date[1], \
        "days,", date[2], "hours,", date[3], "minutes and", date[4], "seconds."

    savedb(db, conf, dbfile)


def c(text):
    if misc.get('color'):
	return C['g'] + text + C['d']
    return text


# Get the category of a title with a certain ID.
def getcat(db, id):
    for d in db:
        if id in db[d].keys():
            return d
    
    # We didn't find it.
    error("Catagory of title with ID '"+c(id)+"' not found.")
    sys.exit(1)





# Detirmine if we're using flatfile or mysql as database.
def flatfile(config):
    if ("database.type" not in config.keys()):
        return True

    if config["database.type"] == "mysql":
        return False

    return True





# Prints formated table with info about items with specified IDs.
def info(db, conf, ids):
    sl_id = 1
    sl_title = 1
    sl_date = 1
    sl_date_added = 1
    sl_category = 1
    items = []

    if flatfile(conf):
        alldbs = db
    else:
        alldbs = getcatsql(db)

    for id in ids:
        found = False
        for d in alldbs:
            if flatfile(conf):
                catids = db[d].keys()
            else:
                cursor = dbexec(db, "SELECT DISTINCT id FROM item WHERE cat = '"+d+"'", None)
                catids = [int(x[0]) for x in cursor.fetchall()]

            if int(id) in catids:
                found = True

                if flatfile(conf):
                    title = db[d][id][1]
                    date = db[d][id][0]
                else:
                    cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
                    result = cursor.fetchall()
                    title = result[0][1]
                    date = result[0][2]

                da = time.gmtime(int(date))
                date_added = str(da[0]) + "-" + str(da[1]) + "-" + str(da[2]) + ", " + \
                    str(da[3]) + ":" + str(da[4]) + ":" + str(da[5])
                date_in_cat = timepassed(date)
                cat = conf["categories." + d]

                items.append((id, title, cat, date_added, date_in_cat))

                if len(id) > sl_id:
                    sl_id = len(id)

                if len(title) > sl_title:
                    sl_title = len(title)

                if len(date_added) > sl_date_added:
                    sl_date_added = len(date_added)

                if len(cat) > sl_category:
                    sl_category = len(cat)

                break;
        
        if not found:
            error("There is no item with ID '" + c(id) + "'.")

    print

    sys.stdout.write("ID")
    for i in (range(sl_id+1)):
        sys.stdout.write(" ")
    sys.stdout.write("TITLE")
    for i in (range(sl_title - 2)):
        sys.stdout.write(" ")
    sys.stdout.write("CATEGORY")
    for i in (range(sl_category - 5)):
        sys.stdout.write(" ")
    sys.stdout.write("DATE ADDED")
    for i in (range(sl_date_added - 7)):
        sys.stdout.write(" ")
    sys.stdout.write("TIME IN CATAGORY")

    print
    print
    for item in items:
        sys.stdout.write(item[0])
        for i in (range(sl_id         - len(item[0]) + 3)):
                sys.stdout.write(" ")

        sys.stdout.write(item[1])
        for i in (range(sl_title      - len(item[1]) + 3)):
                sys.stdout.write(" ")

        sys.stdout.write(item[2])
        for i in (range(sl_category   - len(item[2]) + 3)):
            sys.stdout.write(" ")

        sys.stdout.write(item[3])
        for i in (range(sl_date_added - len(item[3]) + 3)):
            sys.stdout.write(" ")

        print item[4][0]+"y", item[4][1]+"d", item[4][2]+"h", item[4][3]+"m", item[4][4]+"s"
        




def sortdict(adict):
    items = adict.items()
    items.sort()
    return [(key, value) for key, value in items]





def saveconfig(config, configfile):
    #f = open(configfile, 'w')
    #config = sortdict(config)
    #for item in config:
    #    f.write(item[0] + ":" + item[1] + "\n")
    #f.close()

    cf = open(configfile, 'wb')
    for sec in config.sections():
        name = string.lower(sec)
	cf.write("\n[" + name + "]\n")
        for opt in config.options(sec):
            cf.write(string.lower(opt) + ": " + string.strip(config.get(sec, opt)) + "\n")

    cf.close()

    return





def newcategory(configfile, title, id):
    #config["categories." + id] = title
    #config["defval.move-" + id] = id

    sections = ["categories", "defval"]

    config = ConfigParser.ConfigParser()
    config.read(configfile)

    for section in sections:
	if not config.has_section(section):
	    config.add_section(section)

    config.set("categories", id, title)
    config.set("defval", "move-" + id, id)
    config.set("defval", "list", id)

    saveconfig(config, configfile)

    print "Added category '"+c(id)+"' with title '"+c(title)+"'."

    return





def changedb(config, dbfile):
    config["database.type"] = "flatfile"
    db = parsedb(dbfile)

    return db





# Handle command line arguments.
def main():
    # Check if config and database files exists and are read- and writeable.
    if not os.path.exists(DB) or not os.path.exists(CONFIG):
        print C['r'] + "Error: " + C['d'] + "Database and/or config file not found. Should be in ~/.sire/!"
        sys.exit(1)

    # Read the config file.
    config = parseconfig(CONFIG)

    if flatfile(config):
        # Always backup the database before ding anything. Will overwrite older backup.
        shutil.copy(DB, PATH + "/.siredb.backup")
        # First read the database from the file.
        db = parsedb(DB)

    else:
        dbhost = config["database.host"]
        dbuser = config["database.user"]
        dbpass = config["database.pass"]
        dbname = config["database.name"]
        db = MySQLdb.connect(dbhost, dbuser, dbpass, dbname)

    configfile = None
    dbfile = DB

    opts = parseargs()

    if opts.profile is not None:
	profile = opts.profile
        config = parseconfig(ALTRC + profile)
        configfile = ALTRC + profile
        dbfile = ALTDB + profile
        db = changedb(config, dbfile)

    if opts.printid is False:
	misc.set('id', False)

    if opts.printcolor is False:
	misc.set('color', False)

    if opts.printnewline is False:
	misc.set('newline', False)

    if opts.printcat is False:
	misc.set('category', False)

    if opts.hide is True:
	misc.set('id', False)
	misc.set('color', False)
	misc.set('newline', False)
	misc.set('category', False)

    if opts.verbose is not None:
	misc.set('verbose', opts.verbose)

    if opts.force is True:
	misc.set('force', True)

    if opts.edits is not None:
	misc.set('edits', opts.edits)

    # Options that do things comes last.
    if opts.addcat is not None:
	if opts.dest is None:
	    error("Need to specify a category ID. Specify it with --destination, -D.")
	    sys.exit(1)
	newcategory(configfile, opts.addcat, opts.dest)
	return

    if opts.find is not None:
	approxsearch(db, config, misc.get('edits'), opts.find)
	return

    if opts.move is not None:
	id = opts.move
	if opts.dest is not None:
	    newcat = opts.dest
	    move(db, config, id, newcat, dbfile)
	    return

	# User didn't specify what category to move to, try to use the default value.
        if flatfile(config):
            curcat = getcat(db, id)
        else:
            cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
            result = cursor.fetchall()
            curcat = result[0][3]

        # Try default for current category.
        newcat = "defval.move-" + curcat
        if not newcat in config.keys():
            # Otherwise try to use default for all categories.
            if not "defval.move" in config.keys():
                error("Need to specify category, default category not found. Use --destination, -D or edit your config file.")
                sys.exit(1)
            else: newcat = config["defval.move"]
        else: newcat = config[newcat]
        move(db, config, id, newcat, dbfile)

    if opts.change is not None:
	if opts.dest is None:
	    error("No change-to value specified. Specify it using --destination, -D.")
	    sys.exit(1)

        change(db, config, opts.change, opts.dest, dbfile)
	return

    if opts.delete is not None:
        delete(db, config, opts.delete, dbfile)
	return

    if opts.info is not None:
        info(db, config, opts.info)
	return

    if opts.add is not None:
	title = opts.add

	if opts.dest is not None:
	    category = opts.dest
	else:
	    if not "defval.add" in config.keys():
		error("defval.add not specified in config file, and no category specified on command line when adding.")
		sys.exit(1)
	    category = config["defval.add"]

        add(db, config, title, category, dbfile)
	return
	
    # Nothing else was done, so list a category.
    category = None
    if opts.list is not None:
	category = opts.list
    list(db, config, category)
    
    # What to do with the different arguments.
    #for o, a in opts:
        #if o in ("-h", "--help"):
        #    usage()
        #    sys.exit()

        #elif o in ("-n", "--no-id"):
        #    noid = True
        #    continue

        #elif o in ("-t", "--no-category"):
        #    nocat = True
        #    continue

        #elif o in ("-o", "--no-color"):
        #    misc.setcolor(False)
        #    continue

	#elif o in ("-g", "--add-category"):
	#    addcat = True
	#    dolist = False
	#    continue

	#elif o in ("-y", "--category-title"):
	#    newcattitle = a
	#    dolist = False
	#    continue

	#elif o in ("-q", "--quiet"):
	#    misc.setquiet(True)
	#    continue

	#elif o in ("-F", "--force"):
	#    misc.setforce(True)
	#    continue

	#elif o in ("-u", "--category-id"):
	#    newcatid = a
	#    dolist = False
	#    continue

        #elif o in ("-l", "--list"):
        #    category = a
        #    dolist = True
        #    continue

	#elif o in ("-p", "--profile"):
	#    config = parseconfig(ALTRC + a)
	#    configfile = ALTRC + a
	#    dbfile = ALTDB + a
	#    db = changedb(config, dbfile)
	#    continue

        #elif o in ("-w", "--no-newline"):
        #    nonewline = True
        #    continue

	# FIXME: use optparse instead
	#elif o in ("-k", "--temp-add"):
	#    dolist = False
	#    title = sys.argv[4]
	#    category = sys.argv[5]
	#    add(db, config, title, category, dbfile)
	#    continue

        #elif o in ("-a", "--add"):
        #    dolist = False
        #    if len(sys.argv) < 3:
        #        usage()
        #        sys.exit(1)

            # Use default category first.
        #    category = a
	#    if category == '':
        #        category = config["defval.add"]

        #    title = sys.argv[2]
        #    add(db, config, title, category, dbfile)
        #    continue

        #elif o in ("-i", "--info"):
        #    dolist = False
        #    if len(sys.argv) < 3:
        #        usage()
        #        sys.exit(1)

        #    id = sys.argv[2:]
        #    info(db, config, id)
        #    continue

        #elif o in ("-d", "--delete"):
        #    dolist = False
        #    delete(db, config, a, dbfile)
        #    continue

        #elif o in ("-c", "--change"):
        #    dolist = False
        #    if len(sys.argv) < 4:
        #        usage()
        #        sys.exit(1)

        #    id = sys.argv[2]
        #    val = sys.argv[3]

        #    change(db, config, id, val, dbfile)
        #    continue

        #elif o in ("-m", "--move"):
        #    dolist = False
        #    if len(sys.argv) < 3:
        #        usage()
        #        sys.exit(1)
    
        #    id = sys.argv[2]
            
            # User didn't specify what category to move to, try to use the default value.
        #    if len(sys.argv) < 4:
        #        if flatfile(config):
        #            curcat = getcat(db, id)
        #        else:
        #            cursor = dbexec(db, "SELECT * FROM item WHERE id = '"+id+"'", None)
        #            result = cursor.fetchall()
        #            curcat = result[0][3]
    
                # Try default for current category.
        #        newcat = "defval.move-" + curcat
        #        if not newcat in config.keys():
                    # Otherwise try to use default for all categories.
        #            if not "defval.move" in config.keys():
        #                error("Need to specify category, default category not found.")
        #                sys.exit(1)

        #            else:
        #                newcat = config["defval.move"]
        #        else:
        #            newcat = config[newcat]

            # User specified category.
        #    else:
        #        newcat = sys.argv[3]

        #    move(db, config, id, newcat, dbfile)
        #    continue

        #elif o in ("-e", "--edits"):
        #    dolist = False
        #    if len(sys.argv) < 5:
        #        usage()
        #        sys.exit(1)

        #    edits = int(a)
        #    edit_allowed = True
        #    continue
            
        #elif o in ("-f", "--find"):
        #    dolist = False
        #    if len(sys.argv) < 3:
        #        usage()
        #        sys.exit(1)

        #    if edit_allowed:
        #        approxsearch(db, config, edits, sys.argv[4:])

        #    else:
        #        approxsearch(db, config, 0, sys.argv[2:])

        #    continue

        #elif o in ("-v", "--version"):
        #    version()
        #    sys.exit()

        #else:
        #    usage()
        #    sys.exit(1)

    # If no argument given, list items of default category.
    #if dolist:
    #    list(db, config, category, noid, nocat, nonewline)

    #if addcat:
    #	if newcattitle == None:
    #	    error("Need category title. Use --category-title or -y.")
    #	    sys.exit(1)
    
    #	if newcatid == None:
    #	    error("Need category id. Use --category-id or -u.")
    #	    sys.exit(1)

    #	newcategory(configfile, newcattitle, newcatid)

    return




# Call main().
if __name__ == "__main__":
    main()
    sys.exit()
